<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>작업형 2번 코드</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <style>
        /* --- CSS Variables --- */
        :root {
            --bg-primary: #f3f4f6;
            --bg-secondary: #ffffff;
            --text-primary: #1f2937;
            --text-secondary: #374151;
            --border-primary: #d1d5db;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --button-bg: #e5e7eb;
            --button-text: #1f2937;
            --button-hover-bg: #d1d5db;
            --prism-bg: #272822;
            --toggle-bg-off: #e5e7eb;
            --toggle-bg-on: #3b82f6;
            --toggle-knob: #ffffff;
            --nav-button-active-bg: #3b82f6;
            --nav-button-active-text: #ffffff;
            --nav-button-inactive-bg: var(--button-bg);
            --nav-button-inactive-text: var(--button-text);
            --nav-button-inactive-hover-bg: var(--button-hover-bg);
            --hidden-token-bg: #4a4a4a; /* Slightly adjusted solid background */
        }

        html.dark-mode {
            --bg-primary: #111827;
            --bg-secondary: #1f2937;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --border-primary: #4b5563;
            --shadow-color: rgba(0, 0, 0, 0.4);
            --button-bg: #374151;
            --button-text: #f9fafb;
            --button-hover-bg: #4b5563;
            --prism-bg: #272822;
            --toggle-bg-off: #4b5563;
            --toggle-bg-on: #60a5fa;
            --toggle-knob: #ffffff;
            --nav-button-active-bg: #60a5fa;
            --nav-button-active-text: #ffffff;
            --nav-button-inactive-bg: var(--button-bg);
            --nav-button-inactive-text: var(--text-secondary);
            --nav-button-inactive-hover-bg: var(--button-hover-bg);
            --hidden-token-bg: #555;
        }

        /* --- Base Styles --- */
        html, body {
             font-family: 'Inter', sans-serif;
             color: var(--text-primary);
             transition: background-color 0.3s ease, color 0.3s ease;
             margin: 0;
             padding: 0;
             min-height: 100vh;
             background-color: var(--bg-primary);
             touch-action: manipulation; /* 더블 탭 줌 방지 */
        }
        body { padding: 20px; box-sizing: border-box; }
        .container { max-width: 900px; margin: 1rem auto; padding: 1.5rem; background-color: var(--bg-secondary); border-radius: 0.5rem; box-shadow: 0 4px 6px -1px var(--shadow-color), 0 2px 4px -2px var(--shadow-color); transition: background-color 0.3s ease, box-shadow 0.3s ease; }
        h1 { text-align: center; color: var(--text-primary); margin-top: 0; margin-bottom: 1rem; transition: color 0.3s ease; }
        #section-title { text-align: center; font-size: 1.25rem; font-weight: 600; color: var(--text-secondary); margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-primary); }

        /* --- Code Display --- */
        #code-container {
            /* margin-bottom: 1.5rem; */ /* This margin is now on #code-interaction-wrapper */
            border-radius: 0.5rem;
            overflow: hidden;
            flex: 1; /* Occupy 1 part of flex space */
            display: flex; /* To allow child <pre> to grow */
        }
        pre[class*="language-"] { margin: 0 !important; padding: 1em !important; border-radius: 0.5rem; font-size: 0.95em; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; background-color: var(--prism-bg); flex-grow: 1; min-height: 350px; /* Ensure background is set, pre grows and has min height */ }
        code[class*="language-"] { font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; white-space: inherit; word-wrap: inherit; display: block; /* Ensure code block behaves predictably */ }

        /* --- Hidden Token Style --- */
        .hidden-token {
            visibility: hidden;
            background-color: var(--hidden-token-bg) !important;
            border-radius: 2px;
            user-select: none !important;
            pointer-events: none !important;
            text-shadow: none !important;
            box-shadow: none !important;
            border: none !important;
        }
        
        /* --- Controls & Buttons --- */
        #controls { text-align: center; margin-bottom: 1.5rem; }
        .button-group { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; margin-bottom: 1rem; }
        .nav-button { padding: 0.75rem 1.5rem; border: none; border-radius: 0.375rem; cursor: pointer; font-weight: 500; font-size: 1em; transition: background-color 0.3s, color 0.3s, opacity 0.3s; text-decoration: none; display: inline-block; text-align: center; }
        .nav-button.active { background-color: var(--nav-button-active-bg); color: var(--nav-button-active-text); }
        .nav-button:not(.active) { background-color: var(--nav-button-inactive-bg); color: var(--nav-button-inactive-text); }
        .nav-button:not(.active):hover:not(:disabled) { background-color: var(--nav-button-inactive-hover-bg); }
        #reset-button { background-color: var(--button-bg); color: var(--button-text); }
        #reset-button:hover { background-color: var(--button-hover-bg); }
        .nav-button:disabled { opacity: 0.5; cursor: not-allowed; }
        #navigation-buttons { display: flex; justify-content: space-between; margin-top: 1rem; }
        #prev-button, #next-button { width: 48%; }
        
        /* Difficulty selector styling */
        .difficulty-selector { display: flex; align-items: center; }
        #start-difficulty { 
            width: 60px; 
            height: 36px;
            border: 1px solid var(--border-primary);
            border-radius: 0.375rem;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            text-align: center;
            margin-left: 10px;
        }
        #difficulty-max-display {
            margin-left: 5px; /* Space after the input */
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        #apply-difficulty {
            margin-left: 10px; /* Adjusted space after the max display */
            padding: 0.5rem 0.75rem;
        }

        /* --- Theme Toggle --- */
        .theme-toggle-container { text-align: center; margin-bottom: 1rem; color: var(--text-secondary); font-size: 0.9em; }
        .theme-switch-label { position: relative; display: inline-block; width: 50px; height: 26px; cursor: pointer; vertical-align: middle; margin-left: 10px; }
        .theme-switch-label input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--toggle-bg-off); border-radius: 26px; transition: background-color 0.3s; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: var(--toggle-knob); border-radius: 50%; transition: transform 0.3s; }
        input:checked + .slider { background-color: var(--toggle-bg-on); }
        input:checked + .slider:before { transform: translateX(24px); }

        /* --- Code Interaction Layout --- */
        #code-interaction-wrapper {
            display: flex;
            flex-direction: row; /* Explicitly set, though default */
            gap: 15px; /* Space between left and right panels */
            margin-bottom: 1.5rem; /* Overall margin below the component */
        }

        #typing-area-container {
            flex: 1; /* Occupy 1 part of flex space */
            display: flex; /* To allow textarea to fill */
            position: relative; /* For positioning the pre element */
        }

        #user-code-input {
            width: 100%;
            min-height: 350px; /* Same min-height as the code display <pre> */
            box-sizing: border-box;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.95em; /* Match code display */
            line-height: 1.5; /* Match code display */
            
            color: transparent;
            background-color: transparent;
            caret-color: #f8f8f2; 
            
            border: 1px solid var(--border-primary);
            border-radius: 0.5rem; /* Match code display */
            padding: 1em; /* Match code display */
            resize: vertical; 
            
            position: relative; 
            z-index: 1;
            white-space: pre-wrap; 
            word-wrap: break-word; 
            overflow-x: auto; 
        }
        html.dark-mode #user-code-input {
            caret-color: #f8f8f2;
        }
        html:not(.dark-mode) #user-code-input {
            caret-color: var(--text-primary); 
        }

        #highlighting-pre {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            margin: 0 !important; 
            padding: 1em !important; 
            border-radius: 0.5rem; 
            font-size: 0.95em; 
            line-height: 1.5; 
            white-space: pre-wrap; 
            word-wrap: break-word; 
            overflow: auto; 
            background-color: var(--prism-bg); 
            z-index: 0; 
            pointer-events: none; 
            border: 1px solid transparent; 
        }

        #highlighting-pre code {
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; 
            display: block;
        }

        /* Mobile View Toggle Button Style */
        #mobile-view-toggle {
            display: none; /* Hidden by default, shown on mobile via JS/CSS */
            width: 100%;
            margin-bottom: 1rem;
            box-sizing: border-box;
        }

        /* --- Responsive --- */
        @media (max-width: 640px) {
            body { padding: 10px; }
            .container { margin: 0.5rem auto; padding: 1rem; }
            h1 { font-size: 1.5rem; }
            #section-title { font-size: 1.1rem; }
            .nav-button { padding: 0.6rem 1rem; font-size: 0.9em; }
            pre[class*="language-"] { font-size: 0.85em; }
            #prev-button, #next-button { width: 47%; }

            /* Mobile-specific layout changes */
            #mobile-view-toggle {
                /* display: block; is handled by JS, but can be here for initial paint */
            }

            #code-container,
            #typing-area-container {
                width: 100% !important; /* Force full width on mobile when visible */
                flex: none !important; /* Override desktop flex behavior */
                margin-left: 0 !important;
                margin-right: 0 !important;
            }
            /* #code-interaction-wrapper gap will not apply if only one child is visible */
        }
    </style>
</head>
<body>

    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <a href="index.html" class="nav-button" style="background-color: var(--button-bg);">← 돌아가기</a>
          <div class="difficulty-selector">
            시작 난이도: <input type="number" id="start-difficulty" value="0" min="0" max="7" style="width: 60px;">
            <span id="difficulty-max-display">/ 7</span>
            <button id="apply-difficulty" class="nav-button">적용</button>
          </div>
        </div>
        <h1>작업형 2번 코드</h1>
        <div class="theme-toggle-container"> 다크 모드 <label class="theme-switch-label"><input type="checkbox" id="theme-toggle"><span class="slider"></span></label> </div>
        <h2 id="section-title">섹션 로딩 중...</h2>
        
        <!-- NEW BUTTON FOR MOBILE VIEW TOGGLE -->
        <button id="mobile-view-toggle" class="nav-button">연습하기</button>

        <div id="code-interaction-wrapper">
            <div id="code-container">
                <pre><code id="code-display" class="language-python"></code></pre>
            </div>
            <div id="typing-area-container">
                <textarea id="user-code-input" placeholder="여기서 코드를 연습하세요" spellcheck="false" autocapitalize="off" autocomplete="off"></textarea>
                <pre id="highlighting-pre" aria-hidden="true"><code id="highlighting-code" class="language-python"></code></pre>
            </div>
        </div>
        <div id="controls">
            <div class="button-group">
                <button id="difficulty-down-button" class="nav-button">난이도 다운</button>
                <button id="difficulty-up-button" class="nav-button">난이도 업</button>
                <button id="reset-button" class="nav-button">초기화</button>
            </div>
            <div id="navigation-buttons">
                 <button id="prev-button" class="nav-button">이전 섹션</button>
                 <button id="next-button" class="nav-button">다음 섹션</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

    <script>
        const print = (...args) => console.log(...args);
        // --- Code Sections Definition ---
        const codeSections = [
            {
                title: "1. 라이브러리 임포트",
                code: `
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
# from xgboost import XGBClassifier, XGBRegressor
from sklearn.metrics import (
 accuracy_score, f1_score, recall_score, precision_score, roc_auc_score,
 mean_squared_error, mean_absolute_error, mean_absolute_percentage_error, r2_score
)
import numpy as np
                `.trim()
            },
            {
                title: "2. 데이터 로드하기",
                code: `
# 1. 데이터 로드하기 (파일 경로는 상황에 맞게 수정)
x_train = pd.read_csv('data/customer_train.csv')
x_test = pd.read_csv('data/customer_test.csv')
# y_train = pd.read_csv('y_train.csv') # y_train 파일이 존재하는 경우
                `.trim()
            },
            {
                title: "3. 설정값 정의",
                code: `
# 2. 설정: 회규 or 분류
task_type = '분류' # 예측할 데이터가 수치형인 경우 '회귀', 범주형인 경우 '분류' 입력
target_col = '성별' # 예측할 컬럼명 입력
id_col = '회원ID' # ID 컬럼(x_train에 있는 unique한 칼럼(주로 ID칼럼) 입력)
submission_col = 'pred' # 시험에서 주어진 예측 결과 칼럼명
                `.trim()
            },
            {
                title: "4. 타깃 변수 분리",
                code: `
# 3. 타깃 구분하기
drop_cols = [id_col] if id_col else []
# 타깃이 x_train에 포함되어 있는 경우(y_train이 없는 경우)
y = x_train[target_col]
X = x_train.drop(columns=drop_cols + [target_col], errors='ignore')
# y_train이 주어진 경우(주석 해제)
# y = y_train[target_col]
# X = x_train.drop(columns=drop_cols, errors='ignore')
X_test = x_test.drop(columns=drop_cols, errors='ignore')
                `.trim()
            },
            {
                title: "5. 결측치 처리 (옵션)",
                code: `
# 4 결측치 처리 (1가지 선택해서 주석 해제, 결측치 없으면 없어도 됨)
# 1. 모든 결측치 0으로 채우기(빠르고 안정적이지만 점수 낮아질 가능성 존재)
# X = X.fillna(0)
# X_test = X_test.fillna(0)

# 2. 수치형(평균값으로) + 범주형(최빈값으로) 값 처리
# for col in X.columns:
#     val = X[col].mean() if X[col].dtype in ['float64', 'int64'] else X[col].mode()[0]
#     X[col] = X[col].fillna(val)
#     X_test[col] = X_test[col].fillna(val)
                `.trim()
            },
            {
                title: "6. 범주형 인코딩 및 정렬",
                code: `
# 5. 범주형 컬럼 인코딩 + test 컬럼 정렬
X = pd.get_dummies(X)
X_test = pd.get_dummies(X_test)
X_test = X_test.reindex(columns=X.columns, fill_value=0)
                `.trim()
            },
            {
                title: "7. 데이터 분할",
                code: `
# 6. 데이터 분할
X_train, X_val, Y_train, Y_val = train_test_split(
 X, y, test_size=0.3, # 0.2로 변경해서 수치 확인해보고 더 높은걸로 제출
 stratify=y if task_type == '분류' and y.nunique() > 1 else None,
 random_state=42
)
                `.trim()
            },
            {
                title: "8. 모델 선택 및 학습",
                code: `
# 7. 모델 선택 및 학습
if task_type == '분류':
    model = RandomForestClassifier(random_state=42)
    # model = XGBClassifier(use_label_encoder=False, eval_metric='mlogloss', random_state=42)
else:
    model = RandomForestRegressor(random_state=42)
    # model = XGBRegressor(random_state=42)
model.fit(X_train, Y_train)
                `.trim()
            },
            {
                title: "9. 검증 데이터 성능 평가",
                code: `
# 8. 테스트에서 성능 판단 #외우기 힘들면 안 외워도 지장 없지만 점수 확인 후 제출시 필요함
val_pred = model.predict(X_val)
print(f"\\n[검증 결과] ({task_type})")
if task_type == '분류':
    val_proba = model.predict_proba(X_val)[:, 1] if y.nunique() == 2 else None
    print("Accuracy :", accuracy_score(Y_val, val_pred))
    print("Precision:", precision_score(Y_val, val_pred, average='binary' if y.nunique() == 2 else 'macro'))
    print("Recall :", recall_score(Y_val, val_pred, average='binary' if y.nunique() == 2 else 'macro'))
    print("F1 Score :", f1_score(Y_val, val_pred, average='binary' if y.nunique() == 2 else 'macro'))
    if val_proba is not None:
        print("ROC AUC :", roc_auc_score(Y_val, val_proba))
else:
    print("MAE :", mean_absolute_error(Y_val, val_pred))
    print("RMSE :", np.sqrt(mean_squared_error(Y_val, val_pred)))
    print("MAPE :", mean_absolute_percentage_error(Y_val, val_pred))
    print("R2 :", r2_score(Y_val, val_pred))
                `.trim()
            },
            {
                title: "10. 테스트셋 예측",
                code: `
# 9. 테스트셋별 예측(이진분류, 다중분류, 회귀)
if task_type == '분류' and y.nunique() == 2:
    test_pred = model.predict_proba(X_test)[:, 1]
else:
    test_pred = model.predict(X_test)
                `.trim()
            },
            {
                title: "11. 제출 파일 생성",
                code: `
# 10. 제출용 CSV 저장
submission = pd.DataFrame({
    submission_col: test_pred
})
submission.to_csv('00000000_result.csv', index=False)# 결과 제출 양식에 맞춰서 작성하기
                `.trim()
            }
        ];

        // --- 페이지 로드 시 실행 ---
        document.addEventListener('DOMContentLoaded', () => {
            print("DOM 콘텐츠 완전히 로드됨");
            // DOM References
            const codeDisplay = document.getElementById('code-display');
            const sectionTitle = document.getElementById('section-title');
            const resetButton = document.getElementById('reset-button');
            const prevButton = document.getElementById('prev-button');
            const nextButton = document.getElementById('next-button');
            const themeToggle = document.getElementById('theme-toggle');
            const htmlElement = document.documentElement;
            const difficultyUpBtn = document.getElementById('difficulty-up-button');
            const difficultyDownBtn = document.getElementById('difficulty-down-button');
            const applyDifficultyBtn = document.getElementById('apply-difficulty');
            const startDifficultyInput = document.getElementById('start-difficulty');
            const userCodeInput = document.getElementById('user-code-input');
            const highlightingCode = document.getElementById('highlighting-code');
            const highlightingPre = document.getElementById('highlighting-pre');


            // --- State Variables ---
            let currentSectionIndex = 0;
            let hidableElements = []; 
            let tokenGroups = []; 
            let difficultyLevel = 0;
            const maxDifficulty = 7;
            let hiddenIndices = new Set(); 
            let hiddenGroupIndices = new Set(); 
            let defaultDifficultyLevel = 0; 
            let typedCodePerSection = {}; 
            
            if (localStorage.getItem('defaultDifficulty')) {
                defaultDifficultyLevel = parseInt(localStorage.getItem('defaultDifficulty'));
                startDifficultyInput.value = defaultDifficultyLevel;
            }

            // --- Functions ---
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            function prepareHidableElements() {
                const walker = document.createTreeWalker(codeDisplay, NodeFilter.SHOW_TEXT, null, false);
                let node;
                const nodesToReplace = [];
                while(node = walker.nextNode()) {
                    if (node.textContent && !/^[\s\n]+$/.test(node.textContent)) {
                         if (node.parentNode === codeDisplay || node.parentNode.parentNode === codeDisplay) {
                             const span = document.createElement('span');
                             span.className = 'token text-node-token'; 
                             span.textContent = node.textContent;
                             nodesToReplace.push({ oldNode: node, newNode: span });
                         }
                    }
                }
                nodesToReplace.forEach(pair => {
                    try {
                        if (pair.oldNode.parentNode) {
                            pair.oldNode.parentNode.replaceChild(pair.newNode, pair.oldNode);
                        } else {
                             console.warn("교체하려는 노드의 부모가 없습니다:", pair.oldNode);
                        }
                    } catch (e) {
                        console.error("텍스트 노드 교체 중 오류:", e, pair.oldNode);
                    }
                });

                const allTokenSpans = Array.from(codeDisplay.querySelectorAll('span.token'));
                hidableElements = allTokenSpans.filter(span => {
                    const text = span.textContent;
                    return text && !/^[\s\n]+$/.test(text);
                });
                print(`숨길 수 있는 총 요소(수정 후): ${hidableElements.length}개`);
                groupTokensIntoWords(); 
            }

            function groupTokensIntoWords() {
                const tokenData = []; 
                hidableElements.forEach((el, index) => {
                    const text = el.textContent;
                    tokenData.push({
                        el: el,
                        hIndex: index, 
                        text: text,
                        type: el.classList.contains('keyword') ? 'keyword' :
                              el.classList.contains('punctuation') ? 'punctuation' :
                              el.classList.contains('operator') ? 'operator' :
                              (el.classList.contains('function') || /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(text)) ? 'identifier' :
                              'other'
                    });
                });

                if (tokenData.length === 0) {
                    tokenGroups = [];
                    return;
                }

                let finalGroups = []; 
                if (tokenData.length > 0) {
                    finalGroups.push([tokenData[0].hIndex]);
                }

                for (let i = 1; i < tokenData.length; i++) {
                    const currentToken = tokenData[i];
                    const prevToken = tokenData[i - 1];
                    const lastGroup = finalGroups[finalGroups.length - 1]; 

                    const shouldMerge =
                        (currentToken.text === '.' && (prevToken.type === 'identifier' || prevToken.type === 'other')) ||
                        (currentToken.text === ',' && (prevToken.type === 'identifier' || prevToken.type === 'other' || prevToken.text === ')' || prevToken.text === ']')) ||
                        (currentToken.text === '=' && currentToken.type === 'operator' && (prevToken.type === 'identifier' || prevToken.type === 'other')) ||
                        ((currentToken.text === '(' || currentToken.text === '[') && (prevToken.type === 'identifier' || prevToken.type === 'other'));

                    if (shouldMerge && lastGroup) {
                        lastGroup.push(currentToken.hIndex);
                    } else {
                        finalGroups.push([currentToken.hIndex]);
                    }
                }
                tokenGroups = finalGroups.filter(group => group && group.length > 0); 
                print(`${tokenGroups.length}개의 최종 그룹(병합 후 v4) 생성됨.`);
                if (tokenGroups.length > 0) {
                    const finalSampleGroups = tokenGroups.slice(0, Math.min(25, tokenGroups.length)); 
                    print("최종 병합 그룹 샘플 v4 (텍스트):", finalSampleGroups.map(group =>
                        group.map(hIndex => hidableElements[hIndex] ? hidableElements[hIndex].textContent : '?').join('') 
                    ));
                }
            }

            function _loadSectionInternal(newIndexToShow) {
                if (newIndexToShow < 0 || newIndexToShow >= codeSections.length) return;
                
                currentSectionIndex = newIndexToShow; 
                const section = codeSections[currentSectionIndex];

                sectionTitle.textContent = section.title;
                difficultyLevel = defaultDifficultyLevel; 
                hiddenIndices.clear();
                hiddenGroupIndices.clear();
                hidableElements = [];

                codeDisplay.textContent = section.code;
                
                requestAnimationFrame(() => {
                    Prism.highlightElement(codeDisplay);
                    
                    requestAnimationFrame(() => {
                        prepareHidableElements();
                        applyDifficultyLevel();
                        updateDisplay(); 
                        updateButtonStates();
                        print(`섹션 ${currentSectionIndex} 로드되고 하이라이트되었습니다`);
                    });
                });
            }

            function loadSection(newIndexToLoad) {
                if (userCodeInput && typeof currentSectionIndex === 'number') {
                    typedCodePerSection[currentSectionIndex] = userCodeInput.value;
                    print(`Saved typed code for section ${currentSectionIndex}:`, userCodeInput.value.substring(0,50) + "...");
                }

                _loadSectionInternal(newIndexToLoad); 

                if (userCodeInput) {
                    userCodeInput.value = typedCodePerSection[currentSectionIndex] || "";
                    print(`Restored typed code for section ${currentSectionIndex}:`, userCodeInput.value.substring(0,50) + "...");
                    updateHighlighting(); 
                }
            }

            function updateDisplay() {
                print(`화면 업데이트: 난이도=${difficultyLevel}, 숨겨진 토큰=${hiddenIndices.size}/${hidableElements.length}`);
                hidableElements.forEach((el, index) => {
                    if (hiddenIndices.has(index)) { 
                        el.classList.add('hidden-token');
                    } else {
                        el.classList.remove('hidden-token');
                    }
                });
            }

            function updateButtonStates() {
                difficultyUpBtn.disabled = (difficultyLevel >= maxDifficulty);
                difficultyUpBtn.classList.toggle('active', difficultyLevel < maxDifficulty);
                difficultyDownBtn.disabled = (difficultyLevel <= 0);
                difficultyDownBtn.classList.toggle('active', difficultyLevel > 0);

                resetButton.disabled = (difficultyLevel === 0);
                prevButton.disabled = (currentSectionIndex === 0);
                nextButton.disabled = (currentSectionIndex === codeSections.length - 1);
            }

            function setTheme(isDarkMode) { 
                htmlElement.classList.toggle('dark-mode', isDarkMode);
                localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            }
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const initialDarkMode = savedTheme === 'dark' || (!savedTheme && prefersDark);
            themeToggle.checked = initialDarkMode;
            setTheme(initialDarkMode);
            
            themeToggle.addEventListener('change', (event) => setTheme(event.target.checked));
            
            function applyDifficultyLevel() {
                const totalGroups = tokenGroups.length;
                if (totalGroups === 0) {
                     hiddenIndices.clear();
                     hiddenGroupIndices.clear();
                     print("적용할 그룹 없음");
                     return;
                }

                let hideRatio = 0;
                if (difficultyLevel >= maxDifficulty) {
                    hideRatio = 1;
                } else if (difficultyLevel > 0) {
                    const ratiosByLevel = [0, 0.20, 0.35, 0.50, 0.65, 0.80, 0.90]; 
                    hideRatio = ratiosByLevel[difficultyLevel];
                }

                const targetHiddenGroupCount = Math.ceil(totalGroups * hideRatio);
                hiddenIndices.clear();
                hiddenGroupIndices.clear();

                if (targetHiddenGroupCount > 0 && difficultyLevel < maxDifficulty) {
                    const groupIndices = Array.from({length: totalGroups}, (_, i) => i);
                    shuffleArray(groupIndices);
                    const selectedGroupIndices = groupIndices.slice(0, targetHiddenGroupCount);

                    selectedGroupIndices.forEach(groupIdx => {
                        hiddenGroupIndices.add(groupIdx);
                        if (tokenGroups[groupIdx]) {
                            tokenGroups[groupIdx].forEach(hIndex => hiddenIndices.add(hIndex));
                        }
                    });
                } else if (difficultyLevel >= maxDifficulty) {
                    for (let i = 0; i < totalGroups; i++) hiddenGroupIndices.add(i);
                    for (let i = 0; i < hidableElements.length; i++) hiddenIndices.add(i);
                }
                print(`난이도 ${difficultyLevel}, 비율 ${hideRatio}, 숨길 그룹 ${hiddenGroupIndices.size}/${totalGroups}, 숨길 토큰 ${hiddenIndices.size}/${hidableElements.length}`);
            }
            
            applyDifficultyBtn.addEventListener('click', () => {
                let val = parseInt(startDifficultyInput.value);
                if (!isNaN(val) && val >= 0 && val <= maxDifficulty) {
                    difficultyLevel = val;
                    defaultDifficultyLevel = val; 
                    localStorage.setItem('defaultDifficulty', val); 
                    hiddenIndices.clear();
                    hiddenGroupIndices.clear(); 
                    applyDifficultyLevel();
                    updateDisplay();
                    updateButtonStates();
                    print(`난이도 ${difficultyLevel} 적용, ${hiddenIndices.size}개 요소 숨김`);
                }
            });
            
            difficultyUpBtn.addEventListener('click', () => {
                print(`난이도 업 클릭: 현재=${difficultyLevel}, 최대=${maxDifficulty}`);
                if (difficultyLevel >= maxDifficulty || tokenGroups.length === 0) return;
                difficultyLevel++;
                let hideRatio = 0;
                if (difficultyLevel >= maxDifficulty) hideRatio = 1;
                else {
                    const ratiosByLevel = [0, 0.20, 0.35, 0.50, 0.65, 0.80, 0.90]; 
                    hideRatio = ratiosByLevel[difficultyLevel];
                }
                const targetHiddenGroupCount = Math.ceil(tokenGroups.length * hideRatio);
                const currentHiddenGroupCount = hiddenGroupIndices.size;
                const numGroupsToHideAdditionally = Math.max(0, targetHiddenGroupCount - currentHiddenGroupCount);
                print(` -> 새 난이도 ${difficultyLevel}, 목표 그룹 ${targetHiddenGroupCount}, 추가 숨김 ${numGroupsToHideAdditionally}`);
                if (numGroupsToHideAdditionally > 0) {
                    const visibleGroupIndices = [];
                    for (let i = 0; i < tokenGroups.length; i++) {
                        if (!hiddenGroupIndices.has(i)) {
                            visibleGroupIndices.push(i);
                        }
                    }
                    shuffleArray(visibleGroupIndices);
                    const groupsToHideNow = visibleGroupIndices.slice(0, numGroupsToHideAdditionally);
                    groupsToHideNow.forEach(groupIdx => {
                        hiddenGroupIndices.add(groupIdx);
                        if (tokenGroups[groupIdx]) {
                            tokenGroups[groupIdx].forEach(hIndex => hiddenIndices.add(hIndex));
                        }
                    });
                } else if (difficultyLevel >= maxDifficulty) {
                    for (let i = 0; i < tokenGroups.length; i++) hiddenGroupIndices.add(i);
                    for (let i = 0; i < hidableElements.length; i++) hiddenIndices.add(i);
                }
                updateDisplay();
                updateButtonStates();
                print(` -> 최종 숨겨진 그룹 ${hiddenGroupIndices.size}, 토큰 ${hiddenIndices.size}`);
            });
            
            difficultyDownBtn.addEventListener('click', () => {
                print(`난이도 다운 클릭: 현재=${difficultyLevel}`);
                if (difficultyLevel <= 0 || tokenGroups.length === 0) return;
                difficultyLevel--;
                let hideRatio = 0;
                if (difficultyLevel > 0) {
                    const ratiosByLevel = [0, 0.20, 0.35, 0.50, 0.65, 0.80, 0.90]; 
                    hideRatio = ratiosByLevel[difficultyLevel];
                } 
                const targetHiddenGroupCount = Math.ceil(tokenGroups.length * hideRatio);
                const currentHiddenGroupCount = hiddenGroupIndices.size;
                const numGroupsToShow = Math.max(0, currentHiddenGroupCount - targetHiddenGroupCount);
                print(` -> 새 난이도 ${difficultyLevel}, 목표 그룹 ${targetHiddenGroupCount}, 추가 표시 ${numGroupsToShow}`);
                if (numGroupsToShow > 0) {
                    const currentlyHiddenGroupIndices = Array.from(hiddenGroupIndices);
                    shuffleArray(currentlyHiddenGroupIndices);
                    const groupsToShowNow = currentlyHiddenGroupIndices.slice(0, numGroupsToShow);
                    groupsToShowNow.forEach(groupIdx => {
                        hiddenGroupIndices.delete(groupIdx);
                        if (tokenGroups[groupIdx]) {
                            tokenGroups[groupIdx].forEach(hIndex => hiddenIndices.delete(hIndex));
                        }
                    });
                } else if (difficultyLevel === 0) {
                    hiddenGroupIndices.clear();
                    hiddenIndices.clear();
                }
                updateDisplay();
                updateButtonStates();
                print(` -> 최종 숨겨진 그룹 ${hiddenGroupIndices.size}, 토큰 ${hiddenIndices.size}`);
            });
            
            resetButton.addEventListener('click', () => {
                difficultyLevel = 0;
                hiddenIndices.clear();
                hiddenGroupIndices.clear(); 
                applyDifficultyLevel(); 
                updateDisplay();
                updateButtonStates();
            });
            
            prevButton.addEventListener('click', () => {
                if (currentSectionIndex > 0) loadSection(currentSectionIndex - 1);
            });
            
            nextButton.addEventListener('click', () => {
                if (currentSectionIndex < codeSections.length - 1) loadSection(currentSectionIndex + 1);
            });
            
            loadSection(0);

            function syncScroll() {
                highlightingPre.scrollTop = userCodeInput.scrollTop;
                highlightingPre.scrollLeft = userCodeInput.scrollLeft;
            }

            function updateHighlighting() {
                const code = userCodeInput.value;
                highlightingCode.textContent = code + (code.endsWith('\\n') ? '\\n' : ''); 
                Prism.highlightElement(highlightingCode);
                syncScroll(); 
            }

            userCodeInput.addEventListener('input', updateHighlighting);
            userCodeInput.addEventListener('scroll', syncScroll);
            
            userCodeInput.addEventListener('input', () => {
                updateHighlighting();
                if (typeof currentSectionIndex === 'number') {
                    typedCodePerSection[currentSectionIndex] = userCodeInput.value;
                }
            });
            userCodeInput.addEventListener('scroll', syncScroll);
            
            const originalSetTheme = setTheme;
            setTheme = (isDarkMode) => { // Renamed to avoid conflict, ensure this is intended
                originalSetTheme(isDarkMode);
                const currentVal = userCodeInput.value;
                userCodeInput.value = ''; 
                userCodeInput.value = currentVal;
            };

            // --- Mobile View Toggle Logic ---
            const mobileViewToggleButton = document.getElementById('mobile-view-toggle');
            const codeContainerDiv = document.getElementById('code-container');
            const typingAreaContainerDiv = document.getElementById('typing-area-container');
            let mobileView_isTypingVisible = false;

            function setupMobileView() {
                if (!mobileViewToggleButton || !codeContainerDiv || !typingAreaContainerDiv) {
                    console.warn("Mobile view toggle elements not found.");
                    return;
                }

                function updateViewForMobile() {
                    mobileViewToggleButton.style.display = 'block';
                    if (mobileView_isTypingVisible) {
                        codeContainerDiv.style.display = 'none';
                        typingAreaContainerDiv.style.display = 'flex';
                        mobileViewToggleButton.textContent = '코드 보기';
                    } else {
                        codeContainerDiv.style.display = 'flex';
                        typingAreaContainerDiv.style.display = 'none';
                        mobileViewToggleButton.textContent = '연습하기';
                    }
                }

                function updateViewForDesktop() {
                    mobileViewToggleButton.style.display = 'none';
                    codeContainerDiv.style.display = 'flex';
                    typingAreaContainerDiv.style.display = 'flex';
                }

                function handleViewChange() {
                    if (window.innerWidth <= 640) {
                        updateViewForMobile();
                    } else {
                        updateViewForDesktop();
                        // Reset mobile state when switching to desktop for consistency
                        if (mobileView_isTypingVisible) {
                           mobileView_isTypingVisible = false; 
                        }
                    }
                }

                mobileViewToggleButton.addEventListener('click', () => {
                    if (window.innerWidth <= 640) {
                        mobileView_isTypingVisible = !mobileView_isTypingVisible;
                        updateViewForMobile();
                    }
                });

                window.addEventListener('resize', handleViewChange);
                handleViewChange(); // Initial call
            }

            setupMobileView(); // Initialize mobile view handling

        });
    </script>

</body>
</html>
