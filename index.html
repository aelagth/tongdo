<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>빅데이터분석기사 실기 연습</title> <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.css" rel="stylesheet" />
    <style>
        /* CSS Variables (Light Mode Default) */
        :root {
            --bg-primary: #f3f4f6; /* gray-100 */
            --bg-secondary: #ffffff; /* white */
            --bg-tertiary: #f9fafb; /* gray-50 */
            --text-primary: #1f2937; /* gray-800 */
            --text-secondary: #374151; /* gray-700 */
            --text-muted: #6b7280; /* gray-500 */
            --border-primary: #d1d5db; /* gray-300 */
            --border-secondary: #9ca3af; /* gray-400 */
            --shadow-color: rgba(0, 0, 0, 0.1);
            --button-bg: #e5e7eb; /* gray-200 */
            --button-text: #1f2937; /* gray-800 */
            --button-hover-bg: #d1d5db; /* gray-300 */
            --input-bg: #ffffff;
            --input-text: #1f2937;
            --input-border: var(--border-primary);
            --prism-bg: #272822;
            --toggle-bg-off: #e5e7eb; /* gray-200 */
            --toggle-bg-on: #3b82f6;  /* blue-500 */
            --toggle-knob: #ffffff; /* white */
            --nav-button-active-bg: #3b82f6; /* blue-500 */
            --nav-button-active-text: #ffffff; /* white */
            --nav-button-inactive-bg: var(--button-bg);
            --nav-button-inactive-text: var(--button-text);
            --nav-button-inactive-hover-bg: var(--button-hover-bg);
        }

        /* Dark Mode Variables */
        html.dark-mode {
            --bg-primary: #111827; /* gray-900 */
            --bg-secondary: #1f2937; /* gray-800 */
            --bg-tertiary: #374151; /* gray-700 */
            --text-primary: #f9fafb; /* gray-50 */
            --text-secondary: #d1d5db; /* gray-300 */
            --text-muted: #9ca3af; /* gray-400 */
            --border-primary: #4b5563; /* gray-600 */
            --border-secondary: #6b7280; /* gray-500 */
            --shadow-color: rgba(0, 0, 0, 0.4);
            --button-bg: #374151; /* gray-700 */
            --button-text: #f9fafb; /* gray-50 */
            --button-hover-bg: #4b5563; /* gray-600 */
            --input-bg: #1e1e1e;
            --input-text: #d4d4d4;
            --input-border: #3a3d41;
            --prism-bg: #272822;
            --toggle-bg-off: #4b5563; /* gray-600 */
            --toggle-bg-on: #60a5fa;  /* blue-400 */
            --toggle-knob: #ffffff; /* white */
            --nav-button-active-bg: #60a5fa; /* blue-400 */
            --nav-button-active-text: #ffffff; /* white */
            --nav-button-inactive-bg: var(--button-bg);
            --nav-button-inactive-text: var(--button-text);
            --nav-button-inactive-hover-bg: var(--button-hover-bg);
        }

        /* Apply Variables and Transitions */
        html, body {
            font-family: 'Inter', sans-serif;
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background-color: var(--bg-primary);
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
            min-height: 100vh;
            margin: 0;
        }

        .container {
            max-width: 800px;
            margin: 2rem auto;
            padding: 1rem;
            background-color: var(--bg-secondary);
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 1px 3px 0 var(--shadow-color), 0 1px 2px -1px var(--shadow-color);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }
        .problem {
            margin-bottom: 1.5rem; /* mb-6 */
            padding: 1rem;
            background-color: var(--bg-secondary);
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 1px 3px 0 var(--shadow-color), 0 1px 2px -1px var(--shadow-color);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }
        .question {
            font-size: 1.25rem; /* text-xl */
            font-weight: 500; /* font-semibold */
            margin-bottom: 0.5rem; /* mb-2 */
            color: var(--text-primary);
            cursor: pointer; /* 클릭 가능 표시 */
            position: relative; /* For positioning the ::before element */
            padding-left: 20px; /* Space for the +/- icon */
            transition: color 0.3s ease;
        }
        .question::before { content: '+ '; font-weight: bold; position: absolute; left: 0; top: 0; }
        .question.open::before { content: '- '; }
        .question-number { font-weight: 600; margin-right: 0.5rem; }
        .question-text { text-decoration: none; white-space: normal; overflow-wrap: break-word; word-break: break-word; display: inline-block; width: calc(100% - 25px); vertical-align: top; }
        .user-input { width: 100%; min-height: 150px; margin-top: 0.5rem; margin-bottom: 0.5rem; padding: 0.75rem; border: 1px solid var(--input-border); border-radius: 0.375rem; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 0.95rem; background-color: var(--input-bg); color: var(--input-text); display: none; box-sizing: border-box; line-height: 1.5; white-space: pre; overflow-wrap: normal; overflow-x: auto; transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; }
        .check-answer-btn { display: none; padding: 0.5rem 1rem; background-color: #3b82f6; color: white; border: none; border-radius: 0.375rem; cursor: pointer; margin-bottom: 0.5rem; transition: background-color 0.2s; }
        .check-answer-btn:hover { background-color: #2563eb; }
        .answer { font-size: 1rem; margin-bottom: 0.5rem; padding: 0; border-radius: 0.375rem; overflow-x: auto; display: none; border: 1px dashed var(--border-secondary); position: relative; transition: border-color 0.3s ease; cursor: pointer; /* Added cursor pointer */ }
        .code-comment { font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.25rem; margin-top: 0.5rem; padding: 0.5rem; background-color: var(--bg-tertiary); border-left: 3px solid var(--border-primary); display: none; transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; }
        .answer pre[class*="language-"] { margin: 0 !important; border-radius: 0.375rem; padding: 1em !important; font-size: 0.9em; white-space: pre-wrap; word-wrap: break-word; }
        .answer code[class*="language-"] { font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word; }
        h1 { color: var(--text-primary); transition: color 0.3s ease; }

        /* Theme Toggle Switch Styles */
        .theme-switch-label { position: relative; display: inline-block; width: 50px; height: 26px; cursor: pointer; }
        .theme-switch-label input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--toggle-bg-off); border-radius: 26px; transition: background-color 0.3s; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: var(--toggle-knob); border-radius: 50%; transition: transform 0.3s; }
        input:checked + .slider { background-color: var(--toggle-bg-on); }
        input:checked + .slider:before { transform: translateX(24px); }

        /* Navigation Button Styles */
        .nav-button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s, color 0.3s;
            margin-right: 0.5rem; /* Add some spacing */
        }
        .nav-button.active {
            background-color: var(--nav-button-active-bg);
            color: var(--nav-button-active-text);
        }
        .nav-button:not(.active) {
            background-color: var(--nav-button-inactive-bg);
            color: var(--nav-button-inactive-text);
        }
        .nav-button:not(.active):hover {
            background-color: var(--nav-button-inactive-hover-bg);
        }


        /* Basic mobile responsiveness adjustments */
        @media (max-width: 640px) {
            .container { margin: 1rem auto; padding: 0.75rem; }
            .question { font-size: 1.1rem; padding-left: 18px; }
            .answer, .user-input { font-size: 0.9rem; }
            .flex.justify-between.items-start { flex-wrap: wrap; }
            .flex.items-center { margin-top: 0.5rem; }
            .nav-button { margin-bottom: 0.5rem; } /* Stack buttons vertically if needed */
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="flex justify-between items-start mb-4">
            <h1 class="text-2xl font-semibold">빅데이터분석기사 실기 연습</h1> <div class="flex items-center">
                 <label class="theme-switch-label mr-2" for="theme-toggle-checkbox" aria-label="Toggle theme">
                     <input type="checkbox" id="theme-toggle-checkbox">
                     <span class="slider"></span>
                 </label>
                 <button id="reset-progress-btn" class="py-2 px-4 bg-red-500 text-white rounded-md hover:bg-red-600 transition duration-200">진행 상황 초기화</button>
            </div>
        </div>

        <div class="mb-6">
            <button id="show-pandas-btn" class="nav-button active">Pandas 연습 문제</button>
            <button id="show-type3-btn" class="nav-button">작업형 3번 연습</button>
        </div>

        <div id="pandas-practice" class="practice-section">
        <div class="problem" data-question-id="q1">
            <h2 class="question"><span class="question-number">Question 1:</span><span class="question-text">다음 URL의 데이터를 로드하라. 데이터는 \t을 기준으로 구분되어있다.<br>(URL: https://raw.githubusercontent.com/Datamanim/pandas/main/lol.csv)</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">DataUrl = 'https://raw.githubusercontent.com/Datamanim/pandas/main/lol.csv'
df = pd.read_csv(DataUrl, sep='\t')
print(df)
</code></pre>
            </div>
            <p class="code-comment">
                # `pd.read_csv(DataUrl, sep='\\t')`: 지정된 URL에서 데이터를 로드합니다. `sep='\\t'`는 데이터가 탭으로 구분되었음을 의미합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q2">
            <h2 class="question"><span class="question-number">Question 2:</span><span class="question-text">데이터의 상위 5개 행을 출력하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.head(5)
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.head(5)`: 데이터프레임의 처음 5개 행을 선택합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q3">
            <h2 class="question"><span class="question-number">Question 3:</span><span class="question-text">데이터의 행과 열의 갯수를 파악하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">print(df.shape)
print('행:',df.shape[0])
print('열:',df.shape[1])
</code></pre>
            </div>
            <p class="code-comment">
                # `df.shape`: 데이터프레임의 행과 열 개수를 (행, 열) 튜플로 반환합니다.
                # `df.shape[0]`: 행 개수를 반환합니다.
                # `df.shape[1]`: 열 개수를 반환합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q4">
            <h2 class="question"><span class="question-number">Question 4:</span><span class="question-text">전체 컬럼을 출력하라</span></h2>
             <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
             <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.columns
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.columns`: 데이터프레임의 모든 컬럼 이름을 반환합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q5">
             <h2 class="question"><span class="question-number">Question 5:</span><span class="question-text">6번째 컬럼명을 출력하라</span></h2>
             <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
             <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.columns[5]
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.columns[5]`: 데이터프레임의 6번째(인덱스 5) 컬럼 이름을 반환합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q6">
             <h2 class="question"><span class="question-number">Question 6:</span><span class="question-text">6번째 컬럼의 데이터 타입을 확인하라</span></h2>
             <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
             <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.iloc[:,5].dtype
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.iloc[:,5]`: 데이터프레임의 모든 행과 6번째(인덱스 5) 열을 선택합니다.
                # `.dtype`: 선택된 시리즈(컬럼)의 데이터 타입을 반환합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q7">
             <h2 class="question"><span class="question-number">Question 7:</span><span class="question-text">데이터셋의 인덱스 구성은 어떤가</span></h2>
             <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
             <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.index
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.index`: 데이터프레임의 인덱스 객체를 반환합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q8">
             <h2 class="question"><span class="question-number">Question 8:</span><span class="question-text">6번째 컬럼의 3번째 값은 무엇인가?</span></h2>
             <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
             <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.iloc[2,5]
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.iloc[2,5]`: 데이터프레임의 3번째 행(인덱스 2)과 6번째 열(인덱스 5)에 위치한 값을 선택합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q9">
             <h2 class="question"><span class="question-number">Question 9:</span><span class="question-text">다음 URL의 데이터를 로드하라. 컬럼이 한글이기에 적절한 처리해줘야함<br>(URL: https://raw.githubusercontent.com/Datamanim/pandas/main/Jeju.csv)</span></h2>
             <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
             <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">DataUrl = 'https://raw.githubusercontent.com/Datamanim/pandas/main/Jeju.csv'
df = pd.read_csv(DataUrl,encoding='euc-kr')
print(df)
</code></pre>
            </div>
            <p class="code-comment">
                # `pd.read_csv(DataUrl, encoding='euc-kr')`: 지정된 URL의 CSV 파일을 로드합니다. 한글 컬럼명을 위해 `encoding='euc-kr'`를 사용합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q10">
              <h2 class="question"><span class="question-number">Question 10:</span><span class="question-text">데이터 마지막 3개행을 출력하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.tail(3)
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.tail(3)`: 데이터프레임의 마지막 3개 행을 선택합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q11">
              <h2 class="question"><span class="question-number">Question 11:</span><span class="question-text">수치형 변수를 가진 컬럼을 출력하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.select_dtypes(exclude=object).columns
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.select_dtypes(exclude=object)`: 데이터프레임에서 `object` 타입(주로 문자열)을 제외한 컬럼들을 선택합니다.
                # `.columns`: 선택된 데이터프레임의 컬럼 이름들을 반환합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q12">
              <h2 class="question"><span class="question-number">Question 12:</span><span class="question-text">범주형 변수를 가진 컬럼을 출력하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.select_dtypes(include=object).columns
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                 # `df.select_dtypes(include=object)`: 데이터프레임에서 `object` 타입(주로 문자열)인 컬럼들을 선택합니다.
                 # `.columns`: 선택된 데이터프레임의 컬럼 이름들을 반환합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q13">
              <h2 class="question"><span class="question-number">Question 13:</span><span class="question-text">각 컬럼의 결측치 숫자를 파악하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.isnull().sum()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.isnull()`: 데이터프레임의 각 셀이 결측치(NaN)인지 여부를 boolean 값으로 반환합니다.
                # `.sum()`: 각 컬럼별로 True 값(결측치)의 개수를 합산합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q14">
              <h2 class="question"><span class="question-number">Question 14:</span><span class="question-text">각 컬럼의 데이터수, 데이터타입을 한번에 확인하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df.info()
</code></pre>
            </div>
            <p class="code-comment">
                # `df.info()`: 데이터프레임의 간략한 요약 정보(인덱스 타입, 컬럼 정보, non-null 개수, 데이터 타입, 메모리 사용량 등)를 출력합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q15">
              <h2 class="question"><span class="question-number">Question 15:</span><span class="question-text">각 수치형 변수의 분포(사분위, 평균, 표준편차, 최대 , 최소)를 확인하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.describe()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.describe()`: 데이터프레임의 수치형 컬럼에 대한 기술 통계(개수, 평균, 표준편차, 최소값, 사분위수, 최대값)를 계산합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q16">
              <h2 class="question"><span class="question-number">Question 16:</span><span class="question-text">거주인구 컬럼의 값들을 출력하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df['거주인구']
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df['거주인구']`: 데이터프레임에서 '거주인구' 컬럼을 선택합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q17">
              <h2 class="question"><span class="question-number">Question 17:</span><span class="question-text">평균 속도 컬럼의 4분위 범위(IQR) 값을 구하여라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans  = df['평균 속도'].quantile(0.75) -df['평균 속도'].quantile(0.25)
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df['평균 속도'].quantile(0.75)`: '평균 속도' 컬럼의 75% 백분위수(Q3)를 계산합니다.
                # `df['평균 속도'].quantile(0.25)`: '평균 속도' 컬럼의 25% 백분위수(Q1)를 계산합니다.
                # IQR (사분위 범위) = Q3 - Q1 입니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q18">
              <h2 class="question"><span class="question-number">Question 18:</span><span class="question-text">읍면동명 컬럼의 유일값 갯수를 출력하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.읍면동명.nunique()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.읍면동명.nunique()`: '읍면동명' 컬럼의 고유한 값(유일값)의 개수를 계산합니다. `df['읍면동명'].nunique()`와 동일합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q19">
              <h2 class="question"><span class="question-number">Question 19:</span><span class="question-text">읍면동명 컬럼의 유일값을 모두 출력하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.읍면동명.unique()
print(Ans)
</code></pre>
            </div>
             <p class="code-comment">
                # `df.읍면동명.unique()`: '읍면동명' 컬럼의 고유한 값(유일값)들을 NumPy 배열 형태로 반환합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q20">
             <h2 class="question"><span class="question-number">Question 20:</span><span class="question-text">다음 URL의 데이터를 로드하라.<br>(URL: https://raw.githubusercontent.com/Datamanim/pandas/main/chipo.csv)</span></h2>
             <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
             <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python"># Question 20부터 사용할 데이터 로드
DataUrl = 'https://raw.githubusercontent.com/Datamanim/pandas/main/chipo.csv'
df = pd.read_csv(DataUrl)
Ans = type(df)
print(Ans) # 로드된 데이터 타입 확인
# print(df.head()) # 데이터 확인용 출력 추가 (필요 시 주석 해제)
</code></pre>
            </div>
            <p class="code-comment">
                # `pd.read_csv(DataUrl)`: 지정된 URL의 CSV 파일을 로드하여 데이터프레임을 생성합니다.
                # `type(df)`: 로드된 객체(`df`)의 타입을 확인합니다(여기서는 DataFrame).
            </p>
        </div>

        <div class="problem" data-question-id="q21">
               <h2 class="question"><span class="question-number">Question 21:</span><span class="question-text">quantity컬럼 값이 3인 데이터를 추출하여 첫 5행을 출력하라</span></h2>
               <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
               <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.loc[df['quantity']==3].head()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.loc[df['quantity']==3]`: 'quantity' 컬럼 값이 3인 행들을 레이블 기반으로 선택합니다.
                # `.head()`: 선택된 결과의 처음 5개 행을 반환합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q22">
               <h2 class="question"><span class="question-number">Question 22:</span><span class="question-text">quantity컬럼 값이 3인 데이터를 추출하여 index를 0부터 정렬하고 첫 5행을 출력하라</span></h2>
               <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
               <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.loc[df['quantity']==3].head().reset_index(drop=True)
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.loc[df['quantity']==3]`: 'quantity' 컬럼 값이 3인 행들을 선택합니다.
                # `.head()`: 선택된 결과의 처음 5개 행을 반환합니다.
                # `.reset_index(drop=True)`: 기존 인덱스를 제거하고 0부터 시작하는 새로운 정수 인덱스를 설정합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q23">
            <h2 class="question"><span class="question-number">Question 23:</span><span class="question-text">quantity , item_price 두개의 컬럼으로 구성된 새로운 데이터 프레임을 정의하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans =df[['quantity','item_price']]
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df[['quantity','item_price']]`: 데이터프레임에서 'quantity'와 'item_price' 두 개의 컬럼을 선택하여 새로운 데이터프레임을 생성합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q24">
              <h2 class="question"><span class="question-number">Question 24:</span><span class="question-text">item_price 컬럼의 달러표시 문자를 제거하고 float 타입으로 저장하여 new_price 컬럼에 저장하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df['new_price'] = df['item_price'].str[1:].astype('float')
Ans = df['new_price'].head()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df['item_price'].str[1:]`: 'item_price' 컬럼의 각 문자열에서 첫 번째 문자(인덱스 0)를 제외한 나머지 부분을 선택합니다 (달러 기호 제거).
                # `.astype('float')`: 선택된 문자열 시리즈를 부동소수점(float) 타입으로 변환합니다.
                # `df['new_price'] = ...`: 변환된 결과를 'new_price'라는 새로운 컬럼에 저장합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q25">
              <h2 class="question"><span class="question-number">Question 25:</span><span class="question-text">new_price값이 5이하의 값을 가지는 데이터프레임을 추출하고,<br>전체 갯수를 구하여라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = len(df.loc[df.new_price <=5])
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.loc[df.new_price <= 5]`: 'new_price' 컬럼 값이 5 이하인 행들을 선택합니다.
                # `len(...)`: 선택된 데이터프레임의 행의 개수를 반환합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q26">
              <h2 class="question"><span class="question-number">Question 26:</span><span class="question-text">item_name명이 Chicken Salad Bowl 인 데이터 프레임을 추출하고<br>index 값을 초기화 하여라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.loc[df.item_name =='Chicken Salad Bowl'].reset_index(drop=True)
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.loc[df.item_name == 'Chicken Salad Bowl']`: 'item_name' 컬럼 값이 'Chicken Salad Bowl'인 행들을 선택합니다.
                # `.reset_index(drop=True)`: 선택된 결과의 인덱스를 초기화합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q27">
              <h2 class="question"><span class="question-number">Question 27:</span><span class="question-text">new_price값이 9 이하이고 item_name 값이 Chicken Salad Bowl인 데이터 프레임을 추출하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.loc[(df.item_name =='Chicken Salad Bowl') & (df.new_price <= 9)]
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.loc[...]`: 여러 조건을 만족하는 행들을 선택합니다.
                # `(df.item_name == 'Chicken Salad Bowl')`: 첫 번째 조건 (item_name 확인).
                # `(df.new_price <= 9)`: 두 번째 조건 (new_price 확인).
                # `&`: 두 조건을 모두 만족해야 함 (AND 연산).
            </p>
        </div>
        
        <div class="problem" data-question-id="q28">
              <h2 class="question"><span class="question-number">Question 28:</span><span class="question-text">df의 new_price 컬럼 값에 따라 오름차순으로 정리하고 index를 초기화 하여라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.sort_values('new_price').reset_index(drop=True)
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.sort_values('new_price')`: 데이터프레임을 'new_price' 컬럼 기준으로 오름차순 정렬합니다.
                # `.reset_index(drop=True)`: 정렬된 결과의 인덱스를 초기화합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q29">
              <h2 class="question"><span class="question-number">Question 29:</span><span class="question-text">df의 item_name 컬럼 값중 Chips 포함하는 경우의 데이터를 출력하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.loc[df.item_name.str.contains('Chips')]
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.item_name.str.contains('Chips')`: 'item_name' 컬럼의 각 문자열 값에 'Chips'가 포함되어 있는지 확인합니다.
                # `df.loc[...]`: 위 조건이 True인 행들을 선택합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q30">
              <h2 class="question"><span class="question-number">Question 30:</span><span class="question-text">df의 짝수번째 컬럼만을 포함하는 데이터프레임을 출력하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.iloc[:,::2]
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.iloc[:, ::2]`: 데이터프레임의 모든 행(`:`)과 짝수 번째 컬럼(`::2`, 0번부터 시작하여 2칸 간격)을 정수 위치 기반으로 선택합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q31">
              <h2 class="question"><span class="question-number">Question 31:</span><span class="question-text">df의 new_price 컬럼 값에 따라 내림차순으로 정리하고 index를 초기화 하여라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.sort_values('new_price',ascending=False).reset_index(drop=True)
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.sort_values('new_price', ascending=False)`: 데이터프레임을 'new_price' 컬럼 기준으로 내림차순 정렬합니다.
                # `.reset_index(drop=True)`: 정렬된 결과의 인덱스를 초기화합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q32">
              <h2 class="question"><span class="question-number">Question 32:</span><span class="question-text">df의 item_name 컬럼 값이 Steak Salad 또는 Bowl 인 데이터를 인덱싱하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.loc[(df.item_name =='Steak Salad') | (df.item_name =='Bowl')]
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.loc[...]`: 여러 조건을 만족하는 행들을 선택합니다.
                # `(df.item_name == 'Steak Salad')`: 첫 번째 조건.
                # `(df.item_name == 'Bowl')`: 두 번째 조건.
                # `|`: 두 조건 중 하나라도 만족하면 됨 (OR 연산).
            </p>
        </div>
        
        <div class="problem" data-question-id="q33">
              <h2 class="question"><span class="question-number">Question 33:</span><span class="question-text">df의 item_name 컬럼 값이 Steak Salad 또는 Bowl 인 데이터를 데이터 프레임화 한 후,<br>item_name를 기준으로 중복행이 있으면 제거하되 첫번째 케이스만 남겨라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.loc[(df.item_name =='Steak Salad') | (df.item_name =='Bowl')]
Ans = Ans.drop_duplicates('item_name')
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.loc[...]`: 'item_name'이 'Steak Salad' 또는 'Bowl'인 행을 선택합니다.
                # `Ans.drop_duplicates('item_name')`: 선택된 데이터프레임(`Ans`)에서 'item_name' 컬럼 기준으로 중복된 행을 제거하되, 첫 번째 행만 남깁니다. (기본값 `keep='first'`)
            </p>
        </div>
        
        <div class="problem" data-question-id="q34">
              <h2 class="question"><span class="question-number">Question 34:</span><span class="question-text">df의 item_name 컬럼 값이 Steak Salad 또는 Bowl 인 데이터를 데이터 프레임화 한 후,<br>item_name를 기준으로 중복행이 있으면 제거하되 마지막 케이스만 남겨라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.loc[(df.item_name =='Steak Salad') | (df.item_name =='Bowl')]
Ans = Ans.drop_duplicates('item_name',keep='last')
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.loc[...]`: 'item_name'이 'Steak Salad' 또는 'Bowl'인 행을 선택합니다.
                # `Ans.drop_duplicates('item_name', keep='last')`: 선택된 데이터프레임(`Ans`)에서 'item_name' 컬럼 기준으로 중복된 행을 제거하되, 마지막 행만 남깁니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q35">
              <h2 class="question"><span class="question-number">Question 35:</span><span class="question-text">df의 데이터 중 new_price값이 new_price값의 평균값 이상을 가지는<br>데이터들을 인덱싱하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.loc[df.new_price >= df.new_price.mean()]
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.new_price.mean()`: 'new_price' 컬럼의 평균값을 계산합니다.
                # `df.loc[df.new_price >= ... ]`: 'new_price' 컬럼 값이 계산된 평균값 이상인 행들을 선택합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q36">
              <h2 class="question"><span class="question-number">Question 36:</span><span class="question-text">df의 데이터 중 item_name의 값이 Izze 데이터를 Fizzy Lizzy로 수정하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df.loc[df.item_name =='Izze','item_name'] = 'Fizzy Lizzy'
Ans = df
# print(Ans.head()) # 수정 확인 (필요 시 주석 해제)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.loc[df.item_name == 'Izze', 'item_name'] = 'Fizzy Lizzy'`: 'item_name' 컬럼 값이 'Izze'인 행을 선택하고, 해당 행의 'item_name' 값을 'Fizzy Lizzy'로 수정합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q37">
              <h2 class="question"><span class="question-number">Question 37:</span><span class="question-text">df의 데이터 중 choice_description 값이 NaN 인 데이터의 갯수를 구하여라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.choice_description.isnull().sum()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.choice_description.isnull()`: 'choice_description' 컬럼의 각 값이 결측치(NaN)인지 확인합니다.
                # `.sum()`: True 값(결측치)의 개수를 합산합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q38">
              <h2 class="question"><span class="question-number">Question 38:</span><span class="question-text">df의 데이터 중 choice_description 값이 NaN 인 데이터를<br>NoData 값으로 대체하라(loc 이용)</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df.loc[df.choice_description.isnull(),'choice_description'] ='NoData'
Ans = df
# print(Ans.head()) # 수정 확인 (필요 시 주석 해제)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.loc[df.choice_description.isnull(), 'choice_description'] = 'NoData'`: 'choice_description' 컬럼 값이 결측치(NaN)인 행을 선택하고, 해당 행의 'choice_description' 값을 'NoData'로 수정합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q39">
              <h2 class="question"><span class="question-number">Question 39:</span><span class="question-text">df의 데이터 중 choice_description 값에 Black이 들어가는 경우를 인덱싱하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df[df.choice_description.str.contains('Black')]
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                 # `df.choice_description.str.contains('Black')`: 'choice_description' 컬럼의 각 문자열 값에 'Black'이 포함되어 있는지 확인합니다.
                 # `df[...]`: 위 조건이 True인 행들을 선택합니다 (boolean indexing).
            </p>
        </div>
        
        <div class="problem" data-question-id="q40">
              <h2 class="question"><span class="question-number">Question 40:</span><span class="question-text">df의 데이터 중 choice_description 값에 Vegetables 들어가지 않는 경우의<br>갯수를 출력하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = len(df.loc[~df.choice_description.str.contains('Vegetables')])
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.choice_description.str.contains('Vegetables')`: 'Vegetables'가 포함된 경우 True를 반환합니다.
                # `~`: boolean 결과를 반전시킵니다 (포함되지 않은 경우 True).
                # `df.loc[...]`: 조건이 True인 행(Vegetables 미포함)을 선택합니다.
                # `len(...)`: 선택된 행의 개수를 계산합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q41">
              <h2 class="question"><span class="question-number">Question 41:</span><span class="question-text">df의 데이터 중 item_name 값이 N으로 시작하는 데이터를 모두 추출하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df[df.item_name.str.startswith('N')]
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.item_name.str.startswith('N')`: 'item_name' 컬럼의 각 문자열 값이 'N'으로 시작하는지 확인합니다.
                # `df[...]`: 위 조건이 True인 행들을 선택합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q42">
              <h2 class="question"><span class="question-number">Question 42:</span><span class="question-text">df의 데이터 중 item_name 값의 문자열 길이가 15 이상인 데이터를 인덱싱하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans= df[df.item_name.str.len() >=15]
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                 # `df.item_name.str.len()`: 'item_name' 컬럼의 각 문자열 값의 길이를 계산합니다.
                 # `>= 15`: 길이가 15 이상인지 확인합니다.
                 # `df[...]`: 위 조건이 True인 행들을 선택합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q43">
              <h2 class="question"><span class="question-number">Question 43:</span><span class="question-text">df의 데이터 중 new_price값이 list에 해당하는 경우의 데이터 프레임을 구하고<br>그 갯수를 출력하라 lst =[1.69, 2.39, 3.39, 4.45, 9.25, 10.98, 11.75, 16.98]</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">lst =[1.69, 2.39, 3.39, 4.45, 9.25, 10.98, 11.75, 16.98]
Ans = df.loc[df.new_price.isin(lst)]
print(len(Ans)) # 갯수를 출력하라고 했으므로 len() 추가
</code></pre>
            </div>
            <p class="code-comment">
                # `df.new_price.isin(lst)`: 'new_price' 컬럼의 각 값이 주어진 리스트 `lst`에 포함되는지 확인합니다.
                # `df.loc[...]`: 위 조건이 True인 행들을 선택합니다.
                # `len(...)`: 선택된 행의 개수를 계산합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q44">
             <h2 class="question"><span class="question-number">Question 44:</span><span class="question-text">다음 URL의 데이터를 로드하고 상위 5개 행을 출력하라.<br>(URL: https://raw.githubusercontent.com/Datamanim/pandas/main/AB_NYC_2019.csv)</span></h2>
             <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
             <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python"># Question 44부터 사용할 데이터 로드
df= pd.read_csv('https://raw.githubusercontent.com/Datamanim/pandas/main/AB_NYC_2019.csv')
Ans =df.head(5)
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `pd.read_csv(...)`: 지정된 URL의 CSV 파일을 로드합니다.
                # `df.head(5)`: 로드된 데이터프레임의 처음 5개 행을 선택합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q45">
              <h2 class="question"><span class="question-number">Question 45:</span><span class="question-text">데이터의 각 host_name의 빈도수를 구하고 host_name으로 정렬하여<br>상위 5개를 출력하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.groupby('host_name').size().sort_index().head(5)
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.groupby('host_name').size()`: 'host_name' 컬럼 기준으로 그룹화하여 각 그룹의 크기(빈도수)를 계산합니다.
                # `.sort_index()`: 결과를 인덱스(host_name) 기준으로 오름차순 정렬합니다.
                # `.head(5)`: 정렬된 결과의 상위 5개를 선택합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q46">
              <h2 class="question"><span class="question-number">Question 46:</span><span class="question-text">데이터의 각 host_name의 빈도수를 구하고 빈도수 기준 내림차순 정렬한<br>데이터 프레임을 만들어라. 빈도수 컬럼은 counts로 명명하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.groupby('host_name').size().\
                    to_frame().rename(columns={0:'counts'}).\
                    sort_values('counts',ascending=False)
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.groupby('host_name').size()`: 'host_name'별 빈도수를 계산합니다.
                # `.to_frame()`: 시리즈를 데이터프레임으로 변환합니다.
                # `.rename(columns={0:'counts'})`: 변환된 데이터프레임의 컬럼 이름(기본값 0)을 'counts'로 변경합니다.
                # `.sort_values('counts', ascending=False)`: 'counts' 컬럼 기준으로 내림차순 정렬합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q47">
              <h2 class="question"><span class="question-number">Question 47:</span><span class="question-text">neighbourhood_group의 값에 따른 neighbourhood 컬럼 값의 갯수를 구하여라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.groupby(['neighbourhood_group','neighbourhood'], as_index=False).size()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.groupby(['neighbourhood_group','neighbourhood'], as_index=False)`: 두 컬럼으로 그룹화하고, 그룹 키를 인덱스가 아닌 컬럼으로 유지합니다.
                # `.size()`: 각 그룹의 크기(행의 개수)를 계산하여 시리즈로 반환합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q48">
              <h2 class="question"><span class="question-number">Question 48:</span><span class="question-text">neighbourhood_group의 값에 따른 neighbourhood 컬럼 값 중<br>neighbourhood_group 그룹의 최댓값들을 출력하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans= df.groupby(['neighbourhood_group','neighbourhood'], as_index=False).size()\
                    .groupby(['neighbourhood_group'], as_index=False).max()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.groupby(['neighbourhood_group','neighbourhood'], as_index=False).size()`: Q47과 동일하게 그룹별 크기를 계산합니다.
                # `.groupby(['neighbourhood_group'], as_index=False)`: 결과를 다시 'neighbourhood_group'으로 그룹화합니다.
                # `.max()`: 각 'neighbourhood_group' 내에서 최대값(여기서는 size의 최댓값과 해당 neighbourhood)을 찾습니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q49">
              <h2 class="question"><span class="question-number">Question 49:</span><span class="question-text">neighbourhood_group 값에 따른 price 값의 평균, 분산, 최대, 최소 값을 구하여라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df[['neighbourhood_group','price']].groupby('neighbourhood_group').agg(['mean','var','max','min'])
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df[['neighbourhood_group','price']]`: 필요한 두 컬럼만 선택합니다.
                # `.groupby('neighbourhood_group')`: 'neighbourhood_group'으로 그룹화합니다.
                # `.agg(['mean','var','max','min'])`: 각 그룹별로 'price' 컬럼에 대해 평균, 분산, 최대값, 최소값을 계산하는 여러 집계 함수를 적용합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q50">
              <h2 class="question"><span class="question-number">Question 50:</span><span class="question-text">neighbourhood_group 값에 따른 reviews_per_month 평균, 분산, 최대, 최소 값을 구하여라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df[['neighbourhood_group','reviews_per_month']].groupby('neighbourhood_group').agg(['mean','var','max','min'])
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                 # `df[['neighbourhood_group','reviews_per_month']]`: 필요한 두 컬럼만 선택합니다.
                 # `.groupby('neighbourhood_group')`: 'neighbourhood_group'으로 그룹화합니다.
                 # `.agg(['mean','var','max','min'])`: 각 그룹별로 'reviews_per_month' 컬럼에 대해 평균, 분산, 최대값, 최소값을 계산합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q51">
              <h2 class="question"><span class="question-number">Question 51:</span><span class="question-text">neighbourhood 값과 neighbourhood_group 값에 따른 price 의 평균을 구하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.groupby(['neighbourhood','neighbourhood_group']).price.mean()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.groupby(['neighbourhood','neighbourhood_group'])`: 두 컬럼으로 그룹화합니다.
                # `.price`: 그룹화된 객체에서 'price' 컬럼을 선택합니다.
                # `.mean()`: 각 그룹별로 'price'의 평균값을 계산합니다. 결과는 계층적 인덱스를 가집니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q52">
              <h2 class="question"><span class="question-number">Question 52:</span><span class="question-text">neighbourhood 값과 neighbourhood_group 값에 따른 price 의 평균을<br>계층적 indexing 없이 구하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.groupby(['neighbourhood','neighbourhood_group']).price.mean().unstack()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.groupby(['neighbourhood','neighbourhood_group']).price.mean()`: Q51과 동일하게 그룹별 평균을 계산합니다.
                # `.unstack()`: 계층적 인덱스 중 가장 안쪽 레벨('neighbourhood_group')을 컬럼으로 변환하여 테이블 형태로 만듭니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q53">
              <h2 class="question"><span class="question-number">Question 53:</span><span class="question-text">neighbourhood 값과 neighbourhood_group 값에 따른 price 의 평균을<br>계층적 indexing 없이 구하고 nan 값은 -999값으로 채워라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.groupby(['neighbourhood','neighbourhood_group']).price.mean().unstack().fillna(-999)
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.groupby(...).price.mean().unstack()`: Q52와 동일하게 테이블 형태로 만듭니다.
                # `.fillna(-999)`: 테이블 내의 결측치(NaN) 값을 -999로 채웁니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q54">
              <h2 class="question"><span class="question-number">Question 54:</span><span class="question-text">데이터중 neighbourhood_group 값이 Queens 값을 가지는 데이터들 중<br>neighbourhood 그룹별로 price값의 평균, 분산, 최대, 최소값을 구하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
             <div class="answer">
<pre><code class="language-python">Ans = df[df.neighbourhood_group=='Queens'].groupby(['neighbourhood']).price.agg(['mean','var','max','min'])
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df[df.neighbourhood_group=='Queens']`: 'neighbourhood_group'이 'Queens'인 행들만 필터링합니다.
                # `.groupby(['neighbourhood'])`: 필터링된 데이터를 'neighbourhood'로 그룹화합니다.
                # `.price.agg(['mean','var','max','min'])`: 각 'neighbourhood' 그룹별로 'price'의 평균, 분산, 최대, 최소값을 계산합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q55">
              <h2 class="question"><span class="question-number">Question 55:</span><span class="question-text">데이터중 neighbourhood_group 값에 따른 room_type 컬럼의 숫자를 구하고<br>neighbourhood_group 값을 기준으로 각 값의 비율을 구하여라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
             <div class="answer">
<pre><code class="language-python">Ans = df[['neighbourhood_group','room_type']].groupby(['neighbourhood_group','room_type']).size().unstack()
Ans.loc[:,:] = (Ans.values / Ans.sum(axis=1).values.reshape(-1,1))
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df[['neighbourhood_group','room_type']].groupby(...).size().unstack()`: 'neighbourhood_group'별 'room_type'의 개수를 계산하고 테이블 형태로 만듭니다.
                # `Ans.sum(axis=1)`: 각 행(neighbourhood_group)의 합계를 계산합니다.
                # `Ans.values / ... .reshape(-1,1)`: 각 셀의 값을 해당 행의 합계로 나누어 비율을 계산합니다. `.reshape(-1,1)`은 브로드캐스팅을 위해 필요합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q56">
              <h2 class="question"><span class="question-number">Question 56:</span><span class="question-text">다음 URL의 데이터를 로드하고 데이터 행과 열의 갯수를 출력하라<br>(URL: https://raw.githubusercontent.com/Datamanim/pandas/main/BankChurnersUp.csv)</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
             <div class="answer">
<pre><code class="language-python"># Question 56부터 사용할 데이터 로드
df =pd.read_csv('https://raw.githubusercontent.com/Datamanim/pandas/main/BankChurnersUp.csv',index_col=0)
Ans =df.shape
print(Ans)
# print(df.head()) # 데이터 확인용 출력 추가 (필요 시 주석 해제)
</code></pre>
            </div>
            <p class="code-comment">
                 # `pd.read_csv(..., index_col=0)`: CSV 파일을 로드하되, 첫 번째 열을 인덱스로 사용합니다.
                 # `df.shape`: 로드된 데이터프레임의 행과 열의 개수를 반환합니다.
            </p>
        </div>

        <div class="problem" data-question-id="q57">
              <h2 class="question"><span class="question-number">Question 57:</span><span class="question-text">Income_Category의 카테고리를 map 함수를 이용하여 다음과 같이 변경하고<br>newIncome 컬럼에 매핑하라<br>Unknown : N, Less than $40K : a, $40K - $60K : b, $60K - $80K : c, $80K - $120K : d, $120K + : e</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
             <div class="answer">
<pre><code class="language-python">dic = {
    'Unknown'     : 'N',
    'Less than $40K' : 'a',
    '$40K - $60K'    : 'b',
    '$60K - $80K'    : 'c',
    '$80K - $120K'    : 'd',
    '$120K +'        : 'e'    
}
df['newIncome']  =df.Income_Category.map(lambda x: dic[x])
Ans = df['newIncome']
print(Ans.head())
</code></pre>
            </div>
            <p class="code-comment">
                # `dic = {...}`: 카테고리 매핑을 위한 딕셔너리를 정의합니다.
                # `df.Income_Category.map(lambda x: dic[x])`: 'Income_Category' 컬럼의 각 값 `x`를 `dic` 딕셔너리를 이용하여 매핑합니다.
                # `df['newIncome'] = ...`: 매핑된 결과를 'newIncome' 컬럼에 저장합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q58">
            <h2 class="question"><span class="question-number">Question 58:</span><span class="question-text">Income_Category의 카테고리를 apply 함수를 이용하여 다음과 같이 변경하고<br>newIncome 컬럼에 매핑하라<br>Unknown : N, Less than $40K : a, $40K - $60K : b, $60K - $80K : c, $80K - $120K : d, $120K + : e</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">def changeCategory(x):
    if x =='Unknown':
        return 'N'
    elif x =='Less than $40K':
        return 'a'
    elif x =='$40K - $60K':    
        return 'b'
    elif x =='$60K - $80K':    
        return 'c'
    elif x =='$80K - $120K':    
        return 'd'
    elif x =='$120K +' :        
        return 'e'

df['newIncome']  =df.Income_Category.apply(changeCategory)
Ans = df['newIncome']
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `def changeCategory(x): ...`: 값 변환 로직을 담은 함수를 정의합니다.
                # `df.Income_Category.apply(changeCategory)`: 'Income_Category' 컬럼의 각 값에 `changeCategory` 함수를 적용합니다.
                # `df['newIncome'] = ...`: 적용된 결과를 'newIncome' 컬럼에 저장합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q59">
            <h2 class="question"><span class="question-number">Question 59:</span><span class="question-text">Customer_Age의 값을 이용하여 나이 구간을 AgeState 컬럼으로 정의하라.<br>(0~9 : 0, 10~19 :10, 20~29 :20 …) 각 구간의 빈도수를 출력하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df['AgeState']  = df.Customer_Age.map(lambda x: x//10 *10)
Ans = df['AgeState'].value_counts().sort_index()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.Customer_Age.map(lambda x: x//10 * 10)`: 'Customer_Age' 컬럼의 각 값 `x`를 10으로 나눈 몫에 10을 곱하여 10 단위 구간 값으로 변환합니다.
                # `df['AgeState'] = ...`: 변환된 나이 구간 값을 'AgeState' 컬럼에 저장합니다.
                # `.value_counts()`: 'AgeState' 컬럼의 각 값별 빈도수를 계산합니다.
                # `.sort_index()`: 빈도수 결과를 인덱스(나이 구간) 기준으로 정렬합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q60">
            <h2 class="question"><span class="question-number">Question 60:</span><span class="question-text">Education_Level의 값중 Graduate 단어가 포함되는 값은 1,<br>그렇지 않은 경우에는 0으로 변경하여 newEduLevel 컬럼을 정의하고 빈도수를 출력하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df['newEduLevel'] = df.Education_Level.map(lambda x : 1 if 'Graduate' in x else 0)
Ans = df['newEduLevel'].value_counts()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.Education_Level.map(lambda x : 1 if 'Graduate' in x else 0)`: 'Education_Level' 컬럼의 각 값 `x`에 'Graduate'가 포함되면 1, 아니면 0으로 매핑합니다.
                # `df['newEduLevel'] = ...`: 매핑된 결과를 'newEduLevel' 컬럼에 저장합니다.
                # `.value_counts()`: 'newEduLevel' 컬럼의 값(0 또는 1)별 빈도수를 계산합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q61">
            <h2 class="question"><span class="question-number">Question 61:</span><span class="question-text">Credit_Limit 컬럼값이 4500 이상인 경우 1, 그외의 경우에는 모두 0으로 하는<br>newLimit 컬럼을 정의하라. newLimit 각 값들의 빈도수를 출력하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df['newLimit'] = df.Credit_Limit.map(lambda x : 1 if x>=4500 else 0)
Ans = df['newLimit'].value_counts()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.Credit_Limit.map(lambda x : 1 if x>=4500 else 0)`: 'Credit_Limit' 컬럼의 각 값 `x`가 4500 이상이면 1, 아니면 0으로 매핑합니다.
                # `df['newLimit'] = ...`: 매핑된 결과를 'newLimit' 컬럼에 저장합니다.
                # `.value_counts()`: 'newLimit' 컬럼의 값(0 또는 1)별 빈도수를 계산합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q62">
            <h2 class="question"><span class="question-number">Question 62:</span><span class="question-text">Marital_Status 컬럼값이 Married 이고 Card_Category 컬럼의 값이 Platinum인 경우 1,<br>그외의 경우에는 모두 0으로 하는 newState 컬럼을 정의하라. newState의 각 값들의 빈도수를 출력하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">def check(x):
    if x.Marital_Status =='Married' and x.Card_Category =='Platinum':
        return 1
    else:
        return 0

df['newState'] = df.apply(check,axis=1)
Ans  = df['newState'].value_counts()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `def check(x): ...`: 행(`x`)을 입력받아 조건을 확인하고 1 또는 0을 반환하는 함수를 정의합니다.
                # `df.apply(check, axis=1)`: 데이터프레임의 각 행에 `check` 함수를 적용합니다 (`axis=1`).
                # `df['newState'] = ...`: 적용된 결과를 'newState' 컬럼에 저장합니다.
                # `.value_counts()`: 'newState' 컬럼의 값(0 또는 1)별 빈도수를 계산합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q63">
            <h2 class="question"><span class="question-number">Question 63:</span><span class="question-text">Gender 컬럼값 M인 경우 male, F인 경우 female로 값을 변경하여<br>Gender 컬럼에 새롭게 정의하라. 각 value의 빈도를 출력하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">def changeGender(x):
    if x =='M':
        return 'male'
    else:
        return 'female'
df['Gender'] = df.Gender.apply(changeGender)
Ans = df['Gender'].value_counts()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `def changeGender(x): ...`: 성별 값을 변환하는 함수를 정의합니다.
                # `df.Gender.apply(changeGender)`: 'Gender' 컬럼의 각 값에 `changeGender` 함수를 적용합니다.
                # `df['Gender'] = ...`: 변환된 값으로 'Gender' 컬럼을 덮어씁니다.
                # `.value_counts()`: 변경된 'Gender' 컬럼의 값('male', 'female')별 빈도수를 계산합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q64">
            <h2 class="question"><span class="question-number">Question 64:</span><span class="question-text">다음 URL의 데이터를 로드하고 각 열의 데이터 타입을 파악하라<br>(URL: https://raw.githubusercontent.com/Datamanim/pandas/main/timeTest.csv)</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df = pd.read_csv('https://raw.githubusercontent.com/Datamanim/pandas/main/timeTest.csv')
df.info()
</code></pre>
            </div>
            <p class="code-comment">
                # `pd.read_csv(...)`: CSV 파일에서 데이터를 로드합니다.
                # `df.info()`: 로드된 데이터프레임의 각 컬럼별 정보(데이터 타입 포함)를 출력합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q65">
            <h2 class="question"><span class="question-number">Question 65:</span><span class="question-text">Yr_Mo_Dy 컬럼을 판다스에서 인식할 수 있는 datetime64 타입으로 변경하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df.Yr_Mo_Dy = pd.to_datetime(df.Yr_Mo_Dy)
Ans = df.Yr_Mo_Dy
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `pd.to_datetime(df.Yr_Mo_Dy)`: 'Yr_Mo_Dy' 컬럼을 datetime64 타입으로 변환합니다.
                # `df.Yr_Mo_Dy = ...`: 변환된 결과로 컬럼을 덮어씁니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q66">
            <h2 class="question"><span class="question-number">Question 66:</span><span class="question-text">Yr_Mo_Dy에 존재하는 년도의 유일값을 모두 출력하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.Yr_Mo_Dy.dt.year.unique()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.Yr_Mo_Dy.dt.year`: datetime 타입인 'Yr_Mo_Dy' 컬럼에서 연도 정보만 추출합니다.
                # `.unique()`: 추출된 연도 값들 중 고유한 값만 반환합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q67">
            <h2 class="question"><span class="question-number">Question 67:</span><span class="question-text">Yr_Mo_Dy에 년도가 2061년 이상의 경우에는 모두 잘못된 데이터이다.<br>해당 경우의 값은 100을 빼서 새롭게 날짜를 Yr_Mo_Dy 컬럼에 정의하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">def fix_century(x):
    import datetime
    
    year = x.year - 100 if x.year >= 2061 else x.year
    return pd.to_datetime(datetime.date(year, x.month, x.day))

df['Yr_Mo_Dy'] = df['Yr_Mo_Dy'].apply(fix_century)
Ans = df.head(4)
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `def fix_century(x): ...`: datetime 객체 `x`를 받아 연도를 조정하는 함수를 정의합니다. `x.year`, `x.month`, `x.day`로 각 요소에 접근합니다.
                # `pd.to_datetime(...)`: 조정된 년, 월, 일을 다시 datetime 객체로 만듭니다.
                # `df['Yr_Mo_Dy'].apply(fix_century)`: 'Yr_Mo_Dy' 컬럼의 각 datetime 값에 `fix_century` 함수를 적용합니다.
                # `df['Yr_Mo_Dy'] = ...`: 적용된 결과로 컬럼을 덮어씁니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q68">
            <h2 class="question"><span class="question-number">Question 68:</span><span class="question-text">년도별 각컬럼의 평균값을 구하여라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.groupby(df.Yr_Mo_Dy.dt.year).mean()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # `df.Yr_Mo_Dy.dt.year`: datetime 컬럼에서 연도 정보를 추출합니다.
                # `df.groupby(...)`: 추출된 연도 정보를 기준으로 데이터프레임을 그룹화합니다.
                # `.mean()`: 각 연도 그룹별로 모든 수치형 컬럼의 평균값을 계산합니다.
            </p>
        </div>
        
        <div class="problem" data-question-id="q69">
            <h2 class="question"><span class="question-number">Question 69:</span><span class="question-text">weekday 컬럼을 만들고 요일별로 매핑하라 ( 월요일: 0 ~ 일요일 :6)</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df['weekday'] = df.Yr_Mo_Dy.dt.weekday
Ans = df['weekday'].head(3).to_frame()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # 'Yr_Mo_Dy' 컬럼에서 요일을 추출하여 'weekday' 컬럼을 생성합니다. (월요일: 0, 일요일: 6)
            </p>
        </div>
        
        <div class="problem" data-question-id="q70">
            <h2 class="question"><span class="question-number">Question 70:</span><span class="question-text">weekday 컬럼을 기준으로 주말이면 1, 평일이면 0의 값을 가지는<br>WeekCheck 컬럼을 만들어라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df['WeekCheck']  = df['weekday'].map(lambda x : 1 if x in [5,6] else 0)
Ans = df['WeekCheck'].head(3).to_frame()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # 'weekday' 기준 주말(5,6)은 1, 평일은 0으로 'WeekCheck' 생성.
            </p>
        </div>
        
        <div class="problem" data-question-id="q71">
            <h2 class="question"><span class="question-number">Question 71:</span><span class="question-text">년도, 일자 상관없이 모든 컬럼의 각 달의 평균을 구하여라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.dropna(subset=['Yr_Mo_Dy']).groupby(df.Yr_Mo_Dy.dt.month).mean()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # NaN 제거 후, 월별(`.dt.month`) 그룹화하여 컬럼 평균(`.mean()`) 계산.
            </p>
        </div>
        
        <div class="problem" data-question-id="q72">
            <h2 class="question"><span class="question-number">Question 72:</span><span class="question-text">모든 결측치는 컬럼기준 직전의 값으로 대체하고,<br>첫번째 행에 결측치가 있을 경우 뒤에 있는 값으로 대체하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df = df.ffill().bfill()
print(df.head())
</code></pre>
            </div>
            <p class="code-comment">
                # 결측치 처리: 앞 값으로 채우고(`.ffill()`) 뒤 값으로 채움(`.bfill()`).
            </p>
        </div>
        
        <div class="problem" data-question-id="q73">
            <h2 class="question"><span class="question-number">Question 73:</span><span class="question-text">년도-월을 기준으로 모든 컬럼의 평균값을 구하여라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python"># Ensure 'Yr_Mo_Dy' is datetime and no NaT before using to_period
Ans = df.groupby(df.Yr_Mo_Dy.dt.to_period('M')).mean()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # 년-월(`.dt.to_period('M')`) 기준 그룹화 후 컬럼 평균(`.mean()`) 계산.
            </p>
        </div>
        
        <div class="problem" data-question-id="q74">
            <h2 class="question"><span class="question-number">Question 74:</span><span class="question-text">RPT 컬럼의 값을 일자별 기준으로 1차 차분하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df['RPT'].diff()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # 'RPT' 컬럼 1차 차분(`.diff()`) 계산.
            </p>
        </div>
        
        <div class="problem" data-question-id="q75">
            <h2 class="question"><span class="question-number">Question 75:</span><span class="question-text">RPT와 VAL 컬럼을 일주일(7일) 간격으로 각각 이동평균한 값을 구하여라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans= df[['RPT','VAL']].rolling(7).mean()
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # 'RPT', 'VAL' 컬럼 7일 이동 평균(`.rolling(7).mean()`) 계산.
            </p>
        </div>
        
        <div class="problem" data-question-id="q76">
              <h2 class="question"><span class="question-number">Question 76:</span><span class="question-text">서울시 미세먼지 데이터 url: 'https://raw.githubusercontent.com/Datamanim/pandas/main/seoul_pm.csv' 을 읽어들이고<br>'년-월-일:시' 컬럼을 pandas에서 인식할 수 있는 datetime 형태로 변경하라.<br>서울시 제공 데이터의 경우 0시가 24시로 표현된다.</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">def change_date(x):
    import datetime
    hour = x.split(':')[1]
    date = x.split(":")[0]
    
    if hour =='24':
        hour ='00:00:00'
        
        FinalDate = pd.to_datetime(date +" "+hour) + datetime.timedelta(days=1)
        
    else:
        hour = hour +':00:00'
        FinalDate = pd.to_datetime(date +" "+hour)
    
    return FinalDate

df['(년-월-일:시)'] = df['(년-월-일:시)'].apply(change_date)
Ans = df
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # '년-월-일:시' 컬럼 datetime 변환 (24시 -> 다음 날 0시 처리).
            </p>
        </div>
        
        <div class="problem" data-question-id="q77">
              <h2 class="question"><span class="question-number">Question 77:</span><span class="question-text">일자별 영어요일 이름을 dayName 컬럼에 저장하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df['dayName']  = df['(년-월-일:시)'].dt.day_name()
Ans = df['dayName']
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # datetime에서 요일 이름 추출하여 'dayName' 생성.
            </p>
        </div>
        
        <div class="problem" data-question-id="q78">
              <h2 class="question"><span class="question-number">Question 78:</span><span class="question-text">일자별 각 PM10등급의 빈도수를 파악하라</span></h2>
              <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
              <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans1 = df.groupby(['dayName','PM10등급'],as_index=False).size()
Ans2 = Ans1.pivot(index='dayName',columns='PM10등급',values='size').fillna(0)
print(Ans2)
</code></pre>
            </div>
            <p class="code-comment">
                # 요일별, PM10등급별 빈도수 계산 후 피벗 테이블 생성.
            </p>
        </div>
        
        <div class="problem" data-question-id="q79">
            <h2 class="question"><span class="question-number">Question 79:</span><span class="question-text">시간이 연속적으로 존재하며 결측치가 없는지 확인하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python"># 시간을 차분했을 경우 첫 값은 nan, 이후 모든 차분값이 동일하면 연속이라 판단한다.
check = len(df['(년-월-일:시)'].diff().unique())
if check ==2:
    Ans =True
else:
    Ans = False
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # 시간 연속성 확인 (diff().unique() 길이 확인).
            </p>
        </div>
        
        <div class="problem" data-question-id="q80">
            <h2 class="question"><span class="question-number">Question 80:</span><span class="question-text">오전 10시와 오후 10시(22시)의 PM10의 평균값을 각각 구하여라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.groupby(df['(년-월-일:시)'].dt.hour).mean().iloc[[10,22],[0]]
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # 시간별 그룹화 후 10시, 22시 PM10 평균 추출.
            </p>
        </div>
        
        <div class="problem" data-question-id="q81">
            <h2 class="question"><span class="question-number">Question 81:</span><span class="question-text">날짜 컬럼을 index로 만들어라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df.set_index('(년-월-일:시)',inplace=True,drop=True)
Ans =df
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # '(년-월-일:시)' 컬럼을 인덱스로 설정.
            </p>
        </div>
        
        <div class="problem" data-question-id="q82">
            <h2 class="question"><span class="question-number">Question 82:</span><span class="question-text">데이터를 주단위로 뽑아서 최소,최대 평균, 표준편차를 구하여라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.resample('W').agg(['min','max','mean','std'])
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # 주 단위('W') 리샘플링 후 min, max, mean, std 계산.
            </p>
        </div>
        
        <div class="problem" data-question-id="q83">
            <h2 class="question"><span class="question-number">Question 83:</span><span class="question-text">국가별 5세 이하 사망통계 자료<br>'https://raw.githubusercontent.com/Datamanim/pandas/main/under5MortalityRate.csv'를 불러오고<br>Indicator을 삭제하고 First Tooltip 컬럼에서 신뢰구간에 해당하는 표현을 지워라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">df.drop('Indicator',axis=1,inplace=True)
df['First Tooltip'] = df['First Tooltip'].map(lambda x: float(x.split("[")[0]))
Ans = df
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # 'Indicator' 컬럼 삭제, 'First Tooltip'에서 신뢰구간('[...') 제거.
            </p>
        </div>
        
        <div class="problem" data-question-id="q84">
            <h2 class="question"><span class="question-number">Question 84:</span><span class="question-text">년도가 2015년 이상, Dim1이 Both sexes인 케이스만 추출하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">target = df[(df.Period >=2015) & (df.Dim1 =='Both sexes')]
Ans = target
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # Period >= 2015 이고 Dim1 == 'Both sexes'인 행 추출.
            </p>
        </div>
        
        <div class="problem" data-question-id="q85">
            <h2 class="question"><span class="question-number">Question 85:</span><span class="question-text">84번 문제에서 추출한 데이터로 아래와 같이 나라에 따른 년도별 사망률을 데이터 프레임화 하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = target.pivot(index='Location',columns='Period',values='First Tooltip')
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # 나라(Location)별, 연도(Period)별 사망률(First Tooltip) 피벗.
            </p>
        </div>
        
        <div class="problem" data-question-id="q86">
            <h2 class="question"><span class="question-number">Question 86:</span><span class="question-text">Dim1에 따른 년도별 사망비율의 평균을 구하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.pivot_table(index='Dim1',columns='Period',values='First Tooltip',aggfunc='mean')
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # 'Dim1'별, 'Period'별 'First Tooltip' 평균 피벗 테이블.
            </p>
        </div>
        
        <div class="problem" data-question-id="q87">
            <h2 class="question"><span class="question-number">Question 87:</span><span class="question-text">올림픽 메달리스트 정보 데이터<br>url ='https://raw.githubusercontent.com/Datamanim/pandas/main/winter.csv'를 활용하여<br>데이터에서 한국 KOR 데이터만 추출하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">kr = df[df.Country=='KOR']
Ans = kr
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # Country == 'KOR' 행 추출.
            </p>
        </div>
        
        <div class="problem" data-question-id="q88">
            <h2 class="question"><span class="question-number">Question 88:</span><span class="question-text">한국 올림픽 메달리스트 데이터에서 년도에 따른 medal 갯수를 데이터프레임화 하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = kr.pivot_table(index='Year',columns='Medal',aggfunc='size').fillna(0)
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # 한국 데이터(kr)에서 연도별, 메달별 개수 피벗.
            </p>
        </div>
        
        <div class="problem" data-question-id="q89">
            <h2 class="question"><span class="question-number">Question 89:</span><span class="question-text">전체 데이터에서 sport종류에 따른 성별수를 구하여라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.pivot_table(index='Sport',columns='Gender',aggfunc='size')
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # 종목(Sport)별, 성별(Gender) 개수 피벗.
            </p>
        </div>
        
        <div class="problem" data-question-id="q90">
            <h2 class="question"><span class="question-number">Question 90:</span><span class="question-text">전체 데이터에서 Discipline종류에 따른 따른 Medal수를 구하여라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans = df.pivot_table(index='Discipline',columns='Medal',aggfunc='size')
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # 세부 종목(Discipline)별, 메달(Medal)별 개수 피벗 테이블(`.pivot_table()`) 생성.
            </p>
        </div>
        
        <div class="problem" data-question-id="q91">
            <h2 class="question"><span class="question-number">Question 91:</span><span class="question-text">데이터 변형 학습용 데이터<br>url = 'https://raw.githubusercontent.com/Datamanim/pandas/main/mergeTEst.csv'의<br>첫 4개 행을 가진 df1과 나머지 행을 가진 df2의 두 부분으로 나눈뒤<br>df1과 df2 데이터를 하나의 데이터 프레임으로 합쳐라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code>df = pd.read_csv('https://raw.githubusercontent.com/Datamanim/pandas/main/mergeTEst.csv',index_col= 0)
df1 = df.iloc[:4,:]
df2 = df.iloc[4:,:]
display(df1)
display(df2)
total = pd.concat([df1,df2])
Ans = total
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # df1, df2 행 방향 concat.
            </p>
        </div>
        
        <div class="problem" data-question-id="q92">
            <h2 class="question"><span class="question-number">Question 92:</span><span class="question-text">첫 2개 행과 처음 4개 열을 포함하는 dataframe을 df3<br>여섯 번째 행부터 마지막 행과 네 번째 열부터 마지막 열까지 포함하는 dataframe을 df4로 저장한뒤<br>df3과 df4 데이터를 하나의 데이터 프레임으로 합쳐라. 둘다 포함하고 있는 년도에 대해서만 고려한다</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code>df3 = df.iloc[:2,:4]
df4 = df.iloc[5:,3:]
display(df3)
display(df4)
Ans = pd.concat([df3,df4],join='inner')
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # df3, df4 행 방향 concat (inner join).
            </p>
        </div>
        
        <div class="problem" data-question-id="q93">
            <h2 class="question"><span class="question-number">Question 93:</span><span class="question-text">df3과 df4 데이터를 하나의 데이터 프레임으로 합쳐라. 모든 컬럼을 포함하고, 결측치는 0으로 대체한다</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code>Ans = pd.concat([df3,df4],join='outer').fillna(0)
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # df3, df4 행 방향 concat (outer join), NaN은 0으로 fill.
            </p>
        </div>
        
        <div class="problem" data-question-id="q94">
            <h2 class="question"><span class="question-number">Question 94:</span><span class="question-text">전치된 dataframe에서 행 7개와 열 4개를 선택한것을 df5<br>전치된 데이터프레임에서 7번째행부터 마지막 행까지와 3번째 열부터 5번째 열까지를 df6라 할때<br>df5과 df6 데이터를 하나의 데이터 프레임으로 merge함수를 이용하여 합쳐라. Algeria컬럼을 key로 하고 두 데이터 모두 포함하는 데이터만 출력하라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code>Ans = pd.merge(df5,df6,on='Algeria',how='inner')
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # df5, df6 'Algeria' 키로 inner merge.
            </p>
        </div>
        
        <div class="problem" data-question-id="q95">
            <h2 class="question"><span class="question-number">Question 95:</span><span class="question-text">df5과 df6 데이터를 하나의 데이터 프레임으로 merge함수를 이용하여 합쳐라. Algeria컬럼을 key로 하고 합집합으로 합쳐라</span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">Ans =pd.merge(df5,df6,on='Algeria',how='outer')
print(Ans)
</code></pre>
            </div>
            <p class="code-comment">
                # df5, df6 'Algeria' 키로 합집합 병합(`.merge()`, `how='outer'`).
            </p>
        </div>

        <div class="problem" data-question-id="q96">
            <h2 class="question"><span class="question-number">Question 96:</span><span class="question-text">2019년의 데이터를 Min-Max 정규화하고<br>0.5보다 큰 값을 가지는 레코드의 개수를 구하여라 </span></h2>
            <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
            <button class="check-answer-btn">정답 확인</button>
            <div class="answer">
<pre><code class="language-python">import pandas as pd
from sklearn.preprocessing import minmax_scale
df = pd.read_csv('https://raw.githubusercontent.com/Datamanim/pandas/main/mergeTEst.csv',index_col= 0)
df['2019'] = minmax_scale(df['2019'])
print(sum(df['2019'] > 0.5))
</code></pre>
        </div>
        <p class="code-comment">
            # sklearn.preprocessing에 있는 minmax_scale 활용하기기
        </p>
    </div>

        </div> <div id="type3-practice" class="practice-section" style="display: none;"> <div class="problem" data-question-id="t3-q1" data-section="type3">
                <h2 class="question"><span class="question-number">Question 1:</span><span class="question-text">문제 1. 상관관계 분석: 데이터프레임 df에서 'A'와 'B' 변수 간의 피어슨 상관계수를 구하시오.</span></h2>
                <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
                <button class="check-answer-btn">정답 확인</button>
                <div class="answer">
<pre><code class="language-python">import pandas as pd
# 예시 데이터프레임 생성 (실제 문제에서는 주어짐)
# df = pd.DataFrame({'A': [1, 2, 3, 4, 5], 'B': [2, 3, 4, 5, 6]})
correlation = df['A'].corr(df['B'], method='pearson')
print(correlation)
</code></pre>
                </div>
                <p class="code-comment"> # `df['A'].corr(df['B'], method='pearson')`를 사용하여 두 변수 간 피어슨 상관계수를 계산합니다.</p>
            </div>

            <div class="problem" data-question-id="t3-q2" data-section="type3">
                <h2 class="question"><span class="question-number">Question 2:</span><span class="question-text">문제 2. 정규성 검정: 데이터 series가 정규성을 따르는지 검정하시오.</span></h2>
                <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
                <button class="check-answer-btn">정답 확인</button>
                <div class="answer">
<pre><code class="language-python">from scipy import stats
import numpy as np # For example data
# 예시 시리즈 생성 (실제 문제에서는 주어짐)
# series = pd.Series(np.random.randn(100))
stat, p = stats.shapiro(series)
print(f"statistic: {stat}, p-value: {p}")
# 주석: p-value가 유의수준(e.g., 0.05)보다 크면 정규성을 따른다고 볼 수 있습니다.
</code></pre>
                </div>
                 <p class="code-comment"> # `scipy.stats.shapiro()`를 사용하여 Shapiro-Wilk 정규성 검정을 수행합니다. p-value를 확인하여 판단합니다.</p>
            </div>

            <div class="problem" data-question-id="t3-q3" data-section="type3">
                 <h2 class="question"><span class="question-number">Question 3:</span><span class="question-text">문제 3. 일원분산분석: 세 집단 groupA, groupB, groupC 간 평균 차이가 있는지 검정하시오.</span></h2>
                 <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
                 <button class="check-answer-btn">정답 확인</button>
                 <div class="answer">
<pre><code class="language-python">from scipy import stats
import numpy as np # For example data
# 예시 데이터 생성 (실제 문제에서는 주어짐)
# groupA = np.random.normal(5, 1, 30)
# groupB = np.random.normal(5.5, 1, 30)
# groupC = np.random.normal(5, 1, 30)
stat, p = stats.f_oneway(groupA, groupB, groupC)
print(f"statistic: {stat}, p-value: {p}")
# 주석: p-value가 유의수준(e.g., 0.05)보다 작으면 적어도 한 집단의 평균이 다르다고 할 수 있습니다.
</code></pre>
                 </div>
                 <p class="code-comment"> # `scipy.stats.f_oneway()`를 사용하여 일원분산분석(ANOVA)을 수행합니다. p-value를 확인하여 집단 간 평균 차이 유무를 판단합니다.</p>
            </div>

            <div class="problem" data-question-id="t3-q4" data-section="type3">
                <h2 class="question"><span class="question-number">Question 4:</span><span class="question-text">문제 4. 이원분산분석: 범주형 변수 A, B가 종속변수 Y에 영향을 주는지 이원분산분석을 수행하시오.</span></h2>
                <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
                <button class="check-answer-btn">정답 확인</button>
                <div class="answer">
<pre><code class="language-python">import pandas as pd
import statsmodels.api as sm
from statsmodels.formula.api import ols
# 예시 데이터프레임 생성 (실제 문제에서는 주어짐)
# data = {'Y': np.random.rand(20),
#         'A': ['G1']*10 + ['G2']*10,
#         'B': ['X']*5 + ['Y']*5 + ['X']*5 + ['Y']*5}
# df = pd.DataFrame(data)
# C()를 사용하여 범주형 변수임을 명시
model = ols('Y ~ C(A) + C(B) + C(A):C(B)', data=df).fit() # 또는 'Y ~ C(A) * C(B)'
anova_table = sm.stats.anova_lm(model, typ=2) # Type 2 ANOVA 권장
print(anova_table)
# 주석: 각 변수(A, B) 및 상호작용항(A:B)의 p-value (PR(>F))를 확인하여 유의성을 판단합니다.
</code></pre>
                </div>
                <p class="code-comment"> # `statsmodels.formula.api.ols`와 `statsmodels.api.stats.anova_lm`을 사용하여 이원분산분석을 수행합니다. `C()`로 범주형 변수를 명시하고, 상호작용항을 포함합니다.</p>
            </div>

             <div class="problem" data-question-id="t3-q5" data-section="type3">
                 <h2 class="question"><span class="question-number">Question 5:</span><span class="question-text">문제 5. 단일표본 t검정: 집단 sample의 평균이 70보다 큰지 단측 검정하시오.</span></h2>
                 <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
                 <button class="check-answer-btn">정답 확인</button>
                 <div class="answer">
<pre><code class="language-python">from scipy.stats import ttest_1samp
import numpy as np # For example data
# 예시 데이터 생성 (실제 문제에서는 주어짐)
# sample = np.random.normal(72, 5, 50)
popmean = 70
stat, p = ttest_1samp(sample, popmean, alternative='greater') # alternative='greater' for one-sided test (mu > popmean)
print(f"statistic: {stat}, p-value: {p}")
# 주석: p-value가 유의수준(e.g., 0.05)보다 작으면 평균이 70보다 크다는 귀무가설을 기각합니다.
</code></pre>
                 </div>
                 <p class="code-comment"> # `scipy.stats.ttest_1samp()`를 사용하고 `alternative='greater'` 옵션을 주어 단측 검정을 수행합니다.</p>
             </div>

            <div class="problem" data-question-id="t3-q6" data-section="type3">
                 <h2 class="question"><span class="question-number">Question 6:</span><span class="question-text">문제 6. 독립표본 t검정: 두 집단 group1과 group2의 평균이 같은지 검정하시오.</span></h2>
                 <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
                 <button class="check-answer-btn">정답 확인</button>
                 <div class="answer">
<pre><code class="language-python">from scipy.stats import ttest_ind
import numpy as np # For example data
# 예시 데이터 생성 (실제 문제에서는 주어짐)
# group1 = np.random.normal(10, 2, 40)
# group2 = np.random.normal(11, 2, 45)
# 등분산성 가정 여부에 따라 equal_var 파라미터 설정 가능 (기본값=True)
# 등분산 검정 (Levene test) 먼저 수행하는 것이 좋음
# from scipy.stats import levene
# levene_stat, levene_p = levene(group1, group2)
# print(f"Levene test p-value: {levene_p}")
# equal_var_assumption = levene_p > 0.05
stat, p = ttest_ind(group1, group2, equal_var=True) # 또는 equal_var=False (Welch's t-test)
print(f"statistic: {stat}, p-value: {p}")
# 주석: p-value가 유의수준(e.g., 0.05)보다 작으면 두 집단의 평균이 다르다고 할 수 있습니다.
</code></pre>
                 </div>
                 <p class="code-comment"> # `scipy.stats.ttest_ind()`를 사용하여 독립표본 t-검정을 수행합니다. 등분산성 가정 여부(`equal_var`)를 고려해야 합니다.</p>
             </div>

            <div class="problem" data-question-id="t3-q7" data-section="type3">
                 <h2 class="question"><span class="question-number">Question 7:</span><span class="question-text">문제 7. 구간추정: 샘플 sample의 평균에 대한 95% 신뢰구간을 구하시오.</span></h2>
                 <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
                 <button class="check-answer-btn">정답 확인</button>
                 <div class="answer">
<pre><code class="language-python">from scipy import stats
import numpy as np
# 예시 데이터 생성 (실제 문제에서는 주어짐)
# sample = np.random.normal(50, 10, 100)
confidence_level = 0.95
degrees_freedom = len(sample) - 1
sample_mean = np.mean(sample)
sample_standard_error = stats.sem(sample) # Standard Error of the Mean (std/sqrt(n))

# t-분포를 이용한 신뢰구간 계산
ci = stats.t.interval(confidence_level, degrees_freedom, loc=sample_mean, scale=sample_standard_error)

# 또는 직접 계산
# sample_std = np.std(sample, ddof=1) # 표본 표준편차 (ddof=1)
# margin_of_error = stats.t.ppf((1 + confidence_level) / 2., degrees_freedom) * (sample_std / np.sqrt(len(sample)))
# ci = (sample_mean - margin_of_error, sample_mean + margin_of_error)

print(f"{confidence_level*100}% 신뢰구간: {ci}")
</code></pre>
                 </div>
                 <p class="code-comment"> # `scipy.stats.t.interval()` 함수를 이용하여 평균에 대한 t-분포 기반 신뢰구간을 계산합니다. 표본 평균, 자유도, 표준오차(SEM)가 필요합니다.</p>
             </div>

            <div class="problem" data-question-id="t3-q8" data-section="type3">
                 <h2 class="question"><span class="question-number">Question 8:</span><span class="question-text">문제 8. 이항분포 확률: 성공확률이 0.6일 때, 100번 중 60번 성공할 확률을 구하시오.</span></h2>
                 <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
                 <button class="check-answer-btn">정답 확인</button>
                 <div class="answer">
<pre><code class="language-python">from scipy.stats import binom
n = 100 # 총 시도 횟수
k = 60  # 성공 횟수
p = 0.6 # 성공 확률
prob = binom.pmf(k, n, p) # Probability Mass Function (PMF)
print(f"{n}번 중 {k}번 성공할 확률: {prob:.4f}")
</code></pre>
                 </div>
                 <p class="code-comment"> # `scipy.stats.binom.pmf(k, n, p)`를 사용하여 이항분포의 확률질량함수 값을 계산합니다.</p>
             </div>

            <div class="problem" data-question-id="t3-q9" data-section="type3">
                 <h2 class="question"><span class="question-number">Question 9:</span><span class="question-text">문제 9. 카이제곱 독립성 검정: 성별과 합격여부 간의 독립성을 검정하시오.</span></h2>
                 <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
                 <button class="check-answer-btn">정답 확인</button>
                 <div class="answer">
<pre><code class="language-python">from scipy.stats import chi2_contingency
import pandas as pd
# 분할표(Contingency Table) 데이터 생성 (실제 문제에서는 주어짐)
data = {'합격': [100,130], '불합격': [200,170]}
index = ['남자','여자']
df_cont = pd.DataFrame(data, index=index)
print("관측 빈도표:")
print(df_cont)

stat, p, dof, expected = chi2_contingency(df_cont)

print(f"\n카이제곱 통계량(statistic): {stat:.4f}")
print(f"p-value: {p:.4f}")
print(f"자유도(dof): {dof}")
print("\n기대 빈도표:")
print(pd.DataFrame(expected, index=index, columns=data.keys()))
# 주석: p-value가 유의수준(e.g., 0.05)보다 작으면 두 변수(성별, 합격여부)는 독립이 아니라고(연관성이 있다고) 할 수 있습니다.
</code></pre>
                 </div>
                 <p class="code-comment"> # `scipy.stats.chi2_contingency()` 함수에 분할표 데이터를 입력하여 카이제곱 독립성 검정을 수행합니다.</p>
             </div>

            <div class="problem" data-question-id="t3-q10" data-section="type3">
                  <h2 class="question"><span class="question-number">Question 10:</span><span class="question-text">문제 10. 포아송 분포 확률: 하루 평균 3명이 구매할 때, 정확히 5명이 구매할 확률을 구하시오.</span></h2>
                  <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
                  <button class="check-answer-btn">정답 확인</button>
                  <div class="answer">
<pre><code class="language-python">from scipy.stats import poisson
mu = 3 # 평균 발생 횟수 (lambda)
k = 5  # 관심있는 발생 횟수
prob = poisson.pmf(k, mu) # Probability Mass Function (PMF)
print(f"하루 평균 {mu}명 구매 시, 정확히 {k}명이 구매할 확률: {prob:.4f}")
</code></pre>
                  </div>
                  <p class="code-comment"> # `scipy.stats.poisson.pmf(k, mu)`를 사용하여 포아송 분포의 확률질량함수 값을 계산합니다.</p>
              </div>

            <div class="problem" data-question-id="t3-q11" data-section="type3">
                 <h2 class="question"><span class="question-number">Question 11:</span><span class="question-text">문제 11. 연관규칙 (지지도, 신뢰도, 향상도): 빼빼로 → 딴짓초코의 지지도, 신뢰도, 향상도를 구하시오.</span></h2>
                 <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
                 <button class="check-answer-btn">정답 확인</button>
                 <div class="answer">
<pre><code class="language-python">import pandas as pd
# 예시 데이터프레임 생성 (실제 문제에서는 주어짐, 0/1 형태)
# data = {'빼빼로': [1, 0, 1, 1, 0, 1], '딴짓초코': [1, 1, 0, 1, 0, 0], '콜라': [0, 1, 1, 1, 1, 0]}
# df = pd.DataFrame(data)

total_transactions = len(df)
pepero_transactions = df['빼빼로'] == 1
choco_transactions = df['딴짓초코'] == 1

# 빼빼로와 딴짓초코를 동시에 구매한 거래 수
pepero_choco_count = len(df[pepero_transactions & choco_transactions])

# 빼빼로 구매 거래 수
pepero_count = len(df[pepero_transactions])

# 딴짓초코 구매 거래 수
choco_count = len(df[choco_transactions])

# 지지도 (Support): P(빼빼로 ∩ 딴짓초코)
support = pepero_choco_count / total_transactions

# 신뢰도 (Confidence): P(딴짓초코 | 빼빼로) = P(빼빼로 ∩ 딴짓초코) / P(빼빼로)
confidence = pepero_choco_count / pepero_count if pepero_count > 0 else 0

# 향상도 (Lift): P(딴짓초코 | 빼빼로) / P(딴짓초코) = Support / (Support(빼빼로) * Support(딴짓초코))
lift = support / ((pepero_count / total_transactions) * (choco_count / total_transactions)) if pepero_count > 0 and choco_count > 0 else 0
# 또는 lift = confidence / (choco_count / total_transactions)

print(f"지지도 (Support): {support:.4f}")
print(f"신뢰도 (Confidence): {confidence:.4f}")
print(f"향상도 (Lift): {lift:.4f}")
# 주석: Lift > 1 이면 양의 상관관계, Lift < 1 이면 음의 상관관계, Lift = 1 이면 독립.
</code></pre>
                 </div>
                 <p class="code-comment"> # 각 항목(빼빼로, 딴짓초코)의 구매 여부와 동시 구매 여부를 계산하여 지지도, 신뢰도, 향상도를 수식에 따라 계산합니다.</p>
             </div>

            <div class="problem" data-question-id="t3-q12" data-section="type3">
                  <h2 class="question"><span class="question-number">Question 12:</span><span class="question-text">문제 12. 카이제곱 적합도 검정: 관측값 ob와 기대값 expected로 적합도 검정을 수행하시오.</span></h2>
                  <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
                  <button class="check-answer-btn">정답 확인</button>
                  <div class="answer">
<pre><code class="language-python">from scipy.stats import chisquare
# 관측 빈도 (Observed frequencies)
ob = [30, 60, 50, 40, 20]
# 기대 빈도 (Expected frequencies)
expected = [40, 60, 50, 30, 20]

# 기대 빈도가 모두 같지 않으므로 f_exp 파라미터 사용 안 함
stat, p = chisquare(f_obs=ob, f_exp=expected)

print(f"카이제곱 통계량(statistic): {stat:.4f}")
print(f"p-value: {p:.4f}")
# 주석: p-value가 유의수준(e.g., 0.05)보다 작으면 관측 빈도가 기대 빈도와 유의하게 다르다고 할 수 있습니다.
</code></pre>
                  </div>
                  <p class="code-comment"> # `scipy.stats.chisquare(f_obs=관측값리스트, f_exp=기대값리스트)`를 사용하여 카이제곱 적합도 검정을 수행합니다.</p>
              </div>

            <div class="problem" data-question-id="t3-q13" data-section="type3">
                  <h2 class="question"><span class="question-number">Question 13:</span><span class="question-text">문제 13. 로지스틱 회귀분석: 로지스틱 회귀분석 후 오즈비와 정확도를 구하시오.</span></h2>
                  <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
                  <button class="check-answer-btn">정답 확인</button>
                  <div class="answer">
<pre><code class="language-python">import pandas as pd
import numpy as np
from statsmodels.formula.api import logit
from sklearn.model_selection import train_test_split # For splitting example data
from sklearn.metrics import accuracy_score # For accuracy calculation

# 예시 데이터 생성 (실제 문제에서는 train/test 데이터가 주어짐)
# np.random.seed(0)
# data = {'purchase': np.random.randint(0, 2, 100),
#         'income': np.random.normal(50000, 15000, 100)}
# df = pd.DataFrame(data)
# train, test = train_test_split(df, test_size=0.3, random_state=42)

# 로지스틱 회귀 모델 학습 (train 데이터 사용)
# 종속변수 ~ 독립변수1 + 독립변수2 ...
model = logit('purchase ~ income', data=train).fit()
print(model.summary()) # 모델 요약 정보 출력

# 'income' 변수의 오즈비(Odds Ratio) 계산 및 출력
# 오즈비 = exp(회귀계수)
odds_ratio_income = np.exp(model.params['income'])
print(f"\nIncome의 오즈비(Odds Ratio): {odds_ratio_income:.4f}")
# 주석: 오즈비가 1보다 크면 income이 1단위 증가할 때 구매(purchase=1)할 확률이 exp(계수)배 증가함을 의미합니다.

# 테스트 데이터에 대한 예측 (확률 예측 후 0.5 기준으로 분류)
pred_prob = model.predict(test)
pred_class = (pred_prob > 0.5).astype(int)

# 정확도(Accuracy) 계산 및 출력
acc = accuracy_score(test['purchase'], pred_class)
print(f"모델 정확도(Accuracy): {acc:.4f}")
</code></pre>
                  </div>
                  <p class="code-comment"> # `statsmodels.formula.api.logit()`으로 모델을 학습시키고, `np.exp(model.params[변수명])`으로 오즈비를 계산합니다. 예측은 `model.predict()` 후 임계값(0.5)으로 분류하고, `accuracy_score`로 정확도를 계산합니다.</p>
              </div>

            <div class="problem" data-question-id="t3-q14" data-section="type3">
                  <h2 class="question"><span class="question-number">Question 14:</span><span class="question-text">문제 14. 선형회귀 분석: 종속변수 Y와 독립변수 X1, X2로 선형회귀 후 결정계수를 구하시오.</span></h2>
                  <textarea class="user-input" placeholder="여기에 답안을 입력하세요..."></textarea>
                  <button class="check-answer-btn">정답 확인</button>
                  <div class="answer">
<pre><code class="language-python">import pandas as pd
import numpy as np
from statsmodels.formula.api import ols

# 예시 데이터 생성 (실제 문제에서는 데이터프레임 df가 주어짐)
# np.random.seed(1)
# data = {'Y': np.random.rand(50) * 10,
#         'X1': np.random.rand(50) * 5,
#         'X2': np.random.rand(50) * 3}
# df = pd.DataFrame(data)

# 선형 회귀 모델 학습
# 종속변수 ~ 독립변수1 + 독립변수2 ...
model = ols('Y ~ X1 + X2', data=df).fit()
print(model.summary()) # 모델 요약 정보 출력

# 결정계수(R-squared) 및 조정된 결정계수(Adjusted R-squared) 출력
r_squared = model.rsquared
adj_r_squared = model.rsquared_adj

print(f"\n결정계수 (R-squared): {r_squared:.4f}")
print(f"조정된 결정계수 (Adjusted R-squared): {adj_r_squared:.4f}")
# 주석: 결정계수는 모델이 종속변수의 분산을 얼마나 설명하는지를 나타내는 지표 (0~1).
# 조정된 결정계수는 독립변수 개수를 고려하여 보정한 값.
</code></pre>
                  </div>
                   <p class="code-comment"> # `statsmodels.formula.api.ols()`로 모델을 학습시키고, 학습된 모델 객체의 `.rsquared`와 `.rsquared_adj` 속성을 통해 결정계수와 조정된 결정계수를 얻습니다.</p>
              </div>

        </div>
        </div> <script>
        document.addEventListener('DOMContentLoaded', function() {
            // localStorage 키 정의 (섹션별로 구분)
            const storageKeys = {
                pandas: {
                    openProblems: 'openPandasProblems',
                    answerPrefix: 'pandasAnswer_',
                    contentId: 'pandas-practice',
                    buttonId: 'show-pandas-btn'
                },
                type3: {
                    openProblems: 'openType3Problems',
                    answerPrefix: 'type3Answer_',
                    contentId: 'type3-practice',
                    buttonId: 'show-type3-btn'
                }
            };
            const themeKey = 'themePreference';
            const activeSectionKey = 'activePracticeSection'; // 현재 활성화된 섹션 저장

            // 요소 선택
            const resetButton = document.getElementById('reset-progress-btn');
            const themeToggleCheckbox = document.getElementById('theme-toggle-checkbox');
            const body = document.body;
            const html = document.documentElement;

            // --- 테마 설정 로직 ---
            const getCurrentTheme = () => localStorage.getItem(themeKey) || 'light';
            const loadTheme = (theme) => {
                if (theme === 'dark') {
                    html.classList.add('dark-mode');
                    if(themeToggleCheckbox) themeToggleCheckbox.checked = true;
                } else {
                    html.classList.remove('dark-mode');
                     if(themeToggleCheckbox) themeToggleCheckbox.checked = false;
                }
            };
            const currentTheme = getCurrentTheme();
            loadTheme(currentTheme);

            if (themeToggleCheckbox) {
                themeToggleCheckbox.addEventListener('change', () => {
                    const newTheme = themeToggleCheckbox.checked ? 'dark' : 'light';
                    localStorage.setItem(themeKey, newTheme);
                    loadTheme(newTheme);
                });
            }
            // --- 테마 설정 로직 끝 ---

            // --- 섹션 전환 로직 ---
            const sections = document.querySelectorAll('.practice-section');
            const navButtons = document.querySelectorAll('.nav-button');

            function showSection(sectionIdToShow) {
                sections.forEach(section => {
                    section.style.display = section.id === sectionIdToShow ? 'block' : 'none';
                });
                navButtons.forEach(button => {
                    button.classList.toggle('active', button.id === storageKeys[sectionIdToShow.split('-')[0]].buttonId);
                });
                localStorage.setItem(activeSectionKey, sectionIdToShow); // 현재 섹션 저장
            }

            navButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetSectionId = button.id === storageKeys.pandas.buttonId ? storageKeys.pandas.contentId : storageKeys.type3.contentId;
                    showSection(targetSectionId);
                });
            });

            // 페이지 로드 시 마지막 활성 섹션 또는 기본 섹션 로드
            const lastActiveSection = localStorage.getItem(activeSectionKey) || storageKeys.pandas.contentId; // 기본은 Pandas
            showSection(lastActiveSection);
            // --- 섹션 전환 로직 끝 ---

            // --- 문제 상태 및 답안 로드/저장/토글 로직 (섹션 구분 적용) ---
            function initializeSection(sectionKey) {
                const config = storageKeys[sectionKey];
                const sectionDiv = document.getElementById(config.contentId);
                if (!sectionDiv) return;

                const problemDivs = sectionDiv.querySelectorAll('.problem');
                const questions = sectionDiv.querySelectorAll('.question');
                const textInputs = sectionDiv.querySelectorAll('.user-input');
                const checkButtons = sectionDiv.querySelectorAll('.check-answer-btn');
                const answerDivs = sectionDiv.querySelectorAll('.answer');

                // 1. 열린 문제 상태 불러오기 및 복원
                let openProblemIds = new Set(JSON.parse(localStorage.getItem(config.openProblems) || '[]'));
                openProblemIds.forEach(id => {
                    const problemDiv = sectionDiv.querySelector(`.problem[data-question-id="${id}"]`);
                    if (problemDiv) {
                        const questionH2 = problemDiv.querySelector('.question');
                        const userInput = problemDiv.querySelector('.user-input');
                        const checkBtn = problemDiv.querySelector('.check-answer-btn');
                        if (questionH2) questionH2.classList.add('open');
                        if (userInput) userInput.style.display = 'block';
                        if (checkBtn) checkBtn.style.display = 'block';
                         // Ensure comment is also shown if answer was previously revealed and problem is open
                        const answerDiv = problemDiv.querySelector('.answer');
                        const comment = problemDiv.querySelector('.code-comment');
                        if (answerDiv && answerDiv.style.display === 'block' && comment) {
                            comment.style.display = 'block';
                        }
                    }
                });

                // 모든 섹션에 대해 초기 로드 시 입력 영역과 확인 버튼을 항상 보이도록 설정
                textInputs.forEach(input => input.style.display = 'block');
                // 정답이 이미 표시된 경우는 제외하고 확인 버튼 표시
                problemDivs.forEach(problemDiv => {
                    const answerDiv = problemDiv.querySelector('.answer');
                    const checkBtn = problemDiv.querySelector('.check-answer-btn');
                    if (checkBtn && (!answerDiv || answerDiv.style.display !== 'block')) {
                         checkBtn.style.display = 'block';
                    } else if (checkBtn) {
                        checkBtn.style.display = 'none'; // 정답 보이면 숨김
                    }
                });

                // 2. 저장된 사용자 답안 불러오기 및 복원
                textInputs.forEach(textarea => {
                    const problemDiv = textarea.closest('.problem');
                    if (problemDiv && problemDiv.dataset.questionId) {
                         const questionId = problemDiv.dataset.questionId;
                         const answerKey = config.answerPrefix + questionId;
                         const savedAnswer = localStorage.getItem(answerKey);
                         if (savedAnswer !== null) {
                             textarea.value = savedAnswer;
                         }
                         // 3. 사용자 답안 변경 시 localStorage에 저장
                         textarea.addEventListener('input', function() {
                             localStorage.setItem(answerKey, this.value);
                         });
                     }
                });

                // 4. 질문 클릭 시 토글 로직
                questions.forEach(question => {
                    question.addEventListener('click', function() {
                        const problemDiv = this.closest('.problem');
                        if (!problemDiv || !problemDiv.dataset.questionId) return;

                        const questionId = problemDiv.dataset.questionId;
                        const userInput = problemDiv.querySelector('.user-input');
                        const checkBtn = problemDiv.querySelector('.check-answer-btn');
                        const answer = problemDiv.querySelector('.answer');
                        const comment = problemDiv.querySelector('.code-comment');

                        if (!userInput || !checkBtn || !answer ) return; // Comment might not exist

                        const isOpening = !this.classList.contains('open');

                        // 모든 섹션에서 입력 영역은 항상 block 유지
                        userInput.style.display = 'block';
                        // 모든 섹션에서 정답이 보이면 확인 버튼 숨김, 아니면 보임
                        checkBtn.style.display = answer.style.display === 'block' ? 'none' : 'block';

                        let currentOpenIds = new Set(JSON.parse(localStorage.getItem(config.openProblems) || '[]'));
                        if (isOpening) {
                            currentOpenIds.add(questionId);
                             // If answer was previously shown, keep it shown
                            if (answer.style.display !== 'block') {
                                 answer.style.display = 'none';
                                 if(comment) comment.style.display = 'none';
                            } else {
                                if(comment) comment.style.display = 'block'; // Keep comment visible if answer is visible
                                // 정답이 이미 보이면 확인 버튼 숨김 (모든 섹션 공통)
                                checkBtn.style.display = 'none';
                            }
                        } else {
                            // 문제 닫기
                            currentOpenIds.delete(questionId);
                            answer.style.display = 'none';
                            if(comment) comment.style.display = 'none';
                            // 문제 닫을 때 확인 버튼 다시 보이게 (모든 섹션 공통)
                            checkBtn.style.display = 'block';
                        }
                        localStorage.setItem(config.openProblems, JSON.stringify(Array.from(currentOpenIds)));

                        this.classList.toggle('open', isOpening);
                    });
                });

                 // 정답 영역 클릭 시 숨김 로직 (코드 해설도 함께 숨김)
                answerDivs.forEach(answer => {
                    answer.addEventListener('click', function() {
                        this.style.display = 'none'; // 정답 영역 숨김
                        const problemDiv = this.closest('.problem');
                        const comment = problemDiv.querySelector('.code-comment');
                        if (comment) {
                            comment.style.display = 'none'; // 코드 해설 숨김
                        }
                        // 정답 확인 버튼 다시 보이게
                        const checkBtn = problemDiv.querySelector('.check-answer-btn');
                        // const currentSectionKey = problemDiv.closest('.practice-section').id.split('-')[0]; // 이미 위에서 선언됨
                        if (checkBtn) {
                           checkBtn.style.display = 'block';
                        }
                    });
                });

                // 5. 정답 확인 버튼 클릭 로직
                checkButtons.forEach(button => {
                     button.addEventListener('click', function() {
                         const problemDiv = this.closest('.problem');
                         const answerDiv = problemDiv.querySelector('.answer');
                         const comment = problemDiv.querySelector('.code-comment');
                         if (answerDiv) answerDiv.style.display = 'block';
                         if (comment) comment.style.display = 'block'; // Show comment as well
                         this.style.display = 'none'; // Hide the button itself after clicking
                     });
                });
            }

            // 각 섹션 초기화
            initializeSection('pandas');
            initializeSection('type3');
            // --- 문제 상태 로직 끝 ---

            // 6. 진행 상황 초기화 버튼 로직 (모든 섹션 초기화)
            if (resetButton) {
                resetButton.addEventListener('click', function() {
                    if (confirm('정말로 모든 섹션의 진행 상황(열린 문제 및 작성 답안)을 초기화하시겠습니까?')) {
                        // 모든 섹션의 localStorage 데이터 삭제
                        Object.values(storageKeys).forEach(config => {
                             localStorage.removeItem(config.openProblems);
                             // 모든 문제의 답안 삭제 (prefix 기반은 비효율적이므로 문제 ID를 알아야 함)
                             const sectionDiv = document.getElementById(config.contentId);
                             if (sectionDiv) {
                                 sectionDiv.querySelectorAll('.problem').forEach(div => {
                                     const questionId = div.dataset.questionId;
                                     if (questionId) {
                                         localStorage.removeItem(config.answerPrefix + questionId);
                                     }
                                 });
                             }
                        });
                         localStorage.removeItem(activeSectionKey); // 활성 섹션 정보도 초기화

                        // 페이지 새로고침
                        location.reload();
                    }
                });
            }

             // 가짜 객체 정의 (오류 방지용 - Pandas와 통계 라이브러리)
             if (typeof pd === 'undefined') window.pd = { read_csv: () => ({ head: () => '가짜 DataFrame', shape: [1,1], columns: [], index: [], iloc: ()=>{}, tail: ()=>{}, select_dtypes:()=>({columns:[]}), isnull:()=>({sum:()=>0}), info:()=>{}, describe:()=>{}, nunique:()=>0, unique:()=>[], loc:()=>({head:()=>{}, reset_index:()=>{}}), sort_values:()=>({reset_index:()=>{}}), str: {contains:()=>{}, startswith:()=>{}, len:()=>({__ge__:()=>''})}, isin:()=>{}, groupby:()=>({size:()=>({sort_index:()=>{}, to_frame:()=>({rename:()=>({sort_values:()=>{}})})}), mean:()=>{}, agg:()=>{}, price: { mean:()=>({unstack:()=>({fillna:()=>''})})}}), drop:()=>{}, map:()=>{}, apply:()=>{}, diff:()=>{}, rolling:()=>({mean:()=>{}}), dt: { year: { unique: ()=>[] }, weekday: { head: ()=>'' }, month: { mean: ()=>'' }, to_period: ()=>{}, hour: { mean: ()=>'' }, day_name: ()=>'' }, fillna:()=>({fillna:()=>{}}), pivot_table:()=>{}, set_index:()=>{}, resample:()=>({agg:()=>{}}) }), corr:()=>{}, T: {iloc:()=>{}} };
             if (typeof df === 'undefined') window.df = pd.read_csv(''); // Define df globally for snippets
             if (typeof series === 'undefined') window.series = pd.Series ? new pd.Series() : { name: '가짜 Series' };
             if (typeof groupA === 'undefined') window.groupA = [];
             if (typeof groupB === 'undefined') window.groupB = [];
             if (typeof groupC === 'undefined') window.groupC = [];
             if (typeof sample === 'undefined') window.sample = [];
             if (typeof group1 === 'undefined') window.group1 = [];
             if (typeof group2 === 'undefined') window.group2 = [];
             if (typeof train === 'undefined') window.train = pd.DataFrame ? pd.DataFrame({'purchase':[], 'income':[]}) : {columns:[]};
             if (typeof test === 'undefined') window.test = pd.DataFrame ? pd.DataFrame({'purchase':[], 'income':[]}) : {columns:[]};


             if (typeof scipy === 'undefined' || typeof scipy.stats === 'undefined') {
                 window.scipy = { stats: { shapiro: () => [0, 1], f_oneway: () => [0, 1], ttest_1samp: () => [0, 1], ttest_ind: () => [0, 1], t: { interval: () => [0, 1] }, sem:()=>0, binom: { pmf: () => 0 }, chi2_contingency: () => [0, 1, 0, [[1,1],[1,1]]], poisson: { pmf: () => 0 }, chisquare: () => [0, 1] } };
                 window.stats = window.scipy.stats; // Alias for convenience if used directly
             }
             if (typeof statsmodels === 'undefined' || typeof statsmodels.formula === 'undefined') {
                 window.sm = { stats: { anova_lm: () => '가짜 ANOVA 결과' } };
                 window.ols = () => ({ fit: () => ({ summary:()=>console.log('ols.summary()'), params:{}, rsquared: 0, rsquared_adj: 0, predict:()=>(0.5) }) });
                 window.logit = () => ({ fit: () => ({ summary:()=>console.log('logit.summary()'), params:{income:0}, predict:()=>(0.5) }) }); // Ensure params[income] exists
                 // Make ols/logit available globally if imported directly
                 window.statsmodels = { formula: { api: { ols: window.ols, logit: window.logit } }, api: sm };
            }
             if (typeof np === 'undefined') {
                 window.np = { mean: (a) => 0, std: (a, ddof) => 1, sqrt: (a) => 1, exp: (a) => 2.718, random: { randn:()=>0, normal:()=>0, rand:()=>0, randint:()=>0, seed:()=>{} } };
             }
            if (typeof sklearn === 'undefined') {
                window.sklearn = { preprocessing: { minmax_scale: (data) => data }, model_selection: { train_test_split: (d) => [d, d] }, metrics: { accuracy_score: () => 1.0 } };
                // Make minmax_scale directly available if needed
                window.minmax_scale = window.sklearn.preprocessing.minmax_scale;
                window.accuracy_score = window.sklearn.metrics.accuracy_score;
            }

             // display function mock
             window.display = console.log;


            // Prism.js 구문 강조 적용
            Prism.highlightAll();
        });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
